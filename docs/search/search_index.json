{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Human-GEM User Guide Important This guide applies to Human-GEM version v1.12.0 . If you are using a different version of Human-GEM, we cannot guarantee that it will function as described in this guide. Overview This guide contains instructions and examples of how to use Human-GEM , a human genome-scale metabolic model (GEM). Choose a section from the sidebar or the list below to get started! Installation Getting started Flux balance analysis GEM extraction using ftINIT GEM comparison GEM extraction from single-cell RNA-Seq data Additional tools FAQs and troubleshooting Contact Citation J. L. Robinson, et al. An atlas of human metabolism. Sci. Signal. 13, eaaz1482 (2020). doi:10.1126/scisignal.aaz1482","title":"Overview"},{"location":"#human-gem-user-guide","text":"Important This guide applies to Human-GEM version v1.12.0 . If you are using a different version of Human-GEM, we cannot guarantee that it will function as described in this guide.","title":"Human-GEM User Guide"},{"location":"#overview","text":"This guide contains instructions and examples of how to use Human-GEM , a human genome-scale metabolic model (GEM). Choose a section from the sidebar or the list below to get started! Installation Getting started Flux balance analysis GEM extraction using ftINIT GEM comparison GEM extraction from single-cell RNA-Seq data Additional tools FAQs and troubleshooting Contact","title":"Overview"},{"location":"#citation","text":"J. L. Robinson, et al. An atlas of human metabolism. Sci. Signal. 13, eaaz1482 (2020). doi:10.1126/scisignal.aaz1482","title":"Citation"},{"location":"additional_tools/","text":"Additional tools and features The Human-GEM model and repository contain many tools and features that are not covered in detail (or at all) in the examples presented in this guide. These features are described below. Gene ID/name conversion The translateGrRules function enables quick and easy conversion of model gene IDs to a different type, such as gene abbreviations, NCBI (Entrez) IDs, or UniProt IDs. % generate model gene-related fields that use gene names (abbreviations) [grRules, genes, rxnGeneMat] = translateGrRules(model.grRules, 'Name'); % update the model fields with new gene ID type model.grRules = grRules; model.genes = genes; model.rxnGeneMat = rxnGeneMat; In some cases, ID associations are non-unique or missing; e.g., one Ensembl ID is associated with multiple gene names, one gene name is associated with multiple Ensembl IDs, or there is no gene name corresponding to an Ensembl ID. Such cases are handled as follows: 1. Original ID is associated with multiple new IDs The original ID will be replaced with all matching new IDs, which are then formulated as isozymes. For example, if the original grRule is 'geneA and geneB' and geneB is associated with id1 , id2 , and id3 , the new grRule will be 'geneA and (id1 or id2 or id3)' 2. Multiple original IDs are associated with the same new ID The original IDs will be replaced with this new ID, and any duplications in grRules will be automatically detected and removed. For example, if the original grRule is 'geneA or geneB or geneC' and geneB and geneC are both associated with id1 , the new grRule will be 'geneA or id1' 3. Original ID is not associated with any new IDs In this case, the original ID will be removed from the model. Such cases will therefore result in information loss if genes are converted to new IDs and then again back to the original IDs. Note The translateGrRules function has an optional noMatch input, where users can change how IDs without a match are treated. This input defaults to 'delete' , but if 'original' is specified, it will simply keep the original ID. Be aware that this will result in mixed ID types, which may be problematic.","title":"Additional tools"},{"location":"additional_tools/#additional-tools-and-features","text":"The Human-GEM model and repository contain many tools and features that are not covered in detail (or at all) in the examples presented in this guide. These features are described below.","title":"Additional tools and features"},{"location":"additional_tools/#gene-idname-conversion","text":"The translateGrRules function enables quick and easy conversion of model gene IDs to a different type, such as gene abbreviations, NCBI (Entrez) IDs, or UniProt IDs. % generate model gene-related fields that use gene names (abbreviations) [grRules, genes, rxnGeneMat] = translateGrRules(model.grRules, 'Name'); % update the model fields with new gene ID type model.grRules = grRules; model.genes = genes; model.rxnGeneMat = rxnGeneMat; In some cases, ID associations are non-unique or missing; e.g., one Ensembl ID is associated with multiple gene names, one gene name is associated with multiple Ensembl IDs, or there is no gene name corresponding to an Ensembl ID. Such cases are handled as follows: 1. Original ID is associated with multiple new IDs The original ID will be replaced with all matching new IDs, which are then formulated as isozymes. For example, if the original grRule is 'geneA and geneB' and geneB is associated with id1 , id2 , and id3 , the new grRule will be 'geneA and (id1 or id2 or id3)' 2. Multiple original IDs are associated with the same new ID The original IDs will be replaced with this new ID, and any duplications in grRules will be automatically detected and removed. For example, if the original grRule is 'geneA or geneB or geneC' and geneB and geneC are both associated with id1 , the new grRule will be 'geneA or id1' 3. Original ID is not associated with any new IDs In this case, the original ID will be removed from the model. Such cases will therefore result in information loss if genes are converted to new IDs and then again back to the original IDs. Note The translateGrRules function has an optional noMatch input, where users can change how IDs without a match are treated. This input defaults to 'delete' , but if 'original' is specified, it will simply keep the original ID. Be aware that this will result in mixed ID types, which may be problematic.","title":"Gene ID/name conversion"},{"location":"contact/","text":"Contact If you have questions or need additional help in using the Human-GEM model and/or repository, we recommend that you use the Human-GEM Gitter chat or post a question in the Human-GEM Discussions . These options are preferred, because other users are likely to have similar questions, and will be able to see our posted answers. If you find any problems or errors in the Human-GEM model or repository, feel free to create an issue on GitHub. Alternatively, you can email us at contact@metabolicatlas.org .","title":"Contact"},{"location":"contact/#contact","text":"If you have questions or need additional help in using the Human-GEM model and/or repository, we recommend that you use the Human-GEM Gitter chat or post a question in the Human-GEM Discussions . These options are preferred, because other users are likely to have similar questions, and will be able to see our posted answers. If you find any problems or errors in the Human-GEM model or repository, feel free to create an issue on GitHub. Alternatively, you can email us at contact@metabolicatlas.org .","title":"Contact"},{"location":"faq_troubleshoot/","text":"Frequently asked questions and troubleshooting Frequently asked questions (FAQs) Does Human-GEM contain an ATP maintenance reaction? Yes, MAR03964 is an ATP hydrolysis reaction: constructEquations(ihuman, 'MAR03964') ans = 1\u00d71 cell array {'ATP[c] + H2O[c] => ADP[c] + H+[c] + Pi[c]'} Troubleshooting Biomass flux is zero Problem: Running FBA on Human-GEM or a model derived from Human-GEM with a biomass reaction as the objective results in a solution with zero flux, even when all exchange reaction bounds are open. Solution: Convert the model to \"open\" format, meaning that it does not contain any \"boundary\" (\"unconstrained\") metabolites. % using RAVEN: use the simplifyModel function model = simplifyModel(model); % using COBRA: find and remove all boundary metabolites [~, boundary_comp_index] = ismember('Boundary', model.compNames); if isfield(model, 'metComps') model = removeMetabolites(model, model.mets(model.metComps == boundary_comp_index)); end GitHub Discussions For additional questions and discussions related to Human-GEM, check out the Discussions page within the Human-GEM GitHub repository! Feel free to submit a question there if you cannot find a solution to your problem.","title":"FAQs and troubleshooting"},{"location":"faq_troubleshoot/#frequently-asked-questions-and-troubleshooting","text":"","title":"Frequently asked questions and troubleshooting"},{"location":"faq_troubleshoot/#frequently-asked-questions-faqs","text":"","title":"Frequently asked questions (FAQs)"},{"location":"faq_troubleshoot/#does-human-gem-contain-an-atp-maintenance-reaction","text":"Yes, MAR03964 is an ATP hydrolysis reaction: constructEquations(ihuman, 'MAR03964') ans = 1\u00d71 cell array {'ATP[c] + H2O[c] => ADP[c] + H+[c] + Pi[c]'}","title":"Does Human-GEM contain an ATP maintenance reaction?"},{"location":"faq_troubleshoot/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"faq_troubleshoot/#biomass-flux-is-zero","text":"Problem: Running FBA on Human-GEM or a model derived from Human-GEM with a biomass reaction as the objective results in a solution with zero flux, even when all exchange reaction bounds are open. Solution: Convert the model to \"open\" format, meaning that it does not contain any \"boundary\" (\"unconstrained\") metabolites. % using RAVEN: use the simplifyModel function model = simplifyModel(model); % using COBRA: find and remove all boundary metabolites [~, boundary_comp_index] = ismember('Boundary', model.compNames); if isfield(model, 'metComps') model = removeMetabolites(model, model.mets(model.metComps == boundary_comp_index)); end","title":"Biomass flux is zero"},{"location":"faq_troubleshoot/#github-discussions","text":"For additional questions and discussions related to Human-GEM, check out the Discussions page within the Human-GEM GitHub repository! Feel free to submit a question there if you cannot find a solution to your problem.","title":"GitHub Discussions"},{"location":"flux_balance_analysis/","text":"Flux Balance Analysis One of the most common analysis methods for GEMs is flux balance analysis (FBA). This page will briefly walk through the basics of using FBA with Human-GEM. Important You must have a linear optimization solver (e.g., Gurobi) installed and accessible by MATLAB to run FBA. See the installation page of this guide or the RAVEN instructions for details on setting up a solver. Optimization objective By default, the model objective (defined by the .c model field) is set to maximize flux through the generic human biomass reaction ( MAR13082 ), and all exchange reactions are open. ihuman.rxns(ihuman.c == 1) % ans = % % 1\u00d71 cell array % % {'MAR13082'} Run FBA Run FBA using the RAVEN solveLP function. sol = solveLP(ihuman) % sol = % % struct with fields: % % x: [13070\u00d71 double] % f: -187.3536 % stat: 1 % msg: 'Optimal solution found' The sol.f field contains the (negative) value of the objective, and the sol.x vector contains the flux value for each reaction. Important As mentioned, all the exchange reactions are fully opened (upper and lower bounds set to 1000 and -1000, respectively). Therefore, the value of the biomass flux here is meaningless (except that it is nonzero), and its units are undefined. Additional constraints, such as those defining the flux bounds of exchange reactions, are necessary to define a feasible solution space. An FBA example Calculation of ATP yield To illustrate an example of a more meaningful flux solution, we can use FBA to calculate ATP yield (more specifically, the amount of ADP phosphorylated) per glucose consumed. ATP yield can be quantified by the amount of flux through the ATP hydrolysis reaction MAR03964 . constructEquations(ihuman, 'MAR03964') % ans = % % 1\u00d71 cell array % % {'ATP[c] + H2O[c] => ADP[c] + H+[c] + Pi[c]'} Change the objective to maximize flux through the ATP hydrolysis reaction: ihuman = setParam(ihuman, 'obj', 'MAR03964', 1); Prevent import of all metabolites except glucose, for which the max import flux is set to 1 (mmol/gDW/h): ihuman = setExchangeBounds(ihuman, 'glucose', -1); % negative flux indicates import Note By default, the setExchangeBounds function allows unrestricted export of all metabolites. The import of all metabolites is blocked, except for the metabolites specified in the input argument. Now perform FBA to determine the maximum amount of ATP hydrolyzed (ADP phosphorylated) per equivalent of glucose consumed. sol = solveLP(ihuman) % sol = % % struct with fields: % % x: [13070\u00d71 double] % f: -2 % stat: 1 % msg: 'Optimal solution found' As expected, the theoretical mol ADP phosphorylated per mol glucose consumed is 2. Note that we have not allowed the import of oxygen, so this is under anaerobic conditions. This is of course purely theoretical given that most humans produce very little of anything when deprived of oxygen. Let us now calculate the same ATP yield, but in the present of oxygen. We first need to update the exchange constraints: ihuman = setExchangeBounds(ihuman, {'glucose', 'O2'}, [-1, -1000]); Note that we are allowing effectively infinite oxygen consumption, since we are interested in non-O2-limited ATP yield per glucose. Now re-run the FBA to see how the maximum yield has changed: sol = solveLP(ihuman) % sol = % % struct with fields: % % x: [13070\u00d71 double] % f: -31.5000 % stat: 1 % msg: 'Optimal solution found' We now see a much higher ATP yield per glucose consumed of 31.5.","title":"Flux balance analysis"},{"location":"flux_balance_analysis/#flux-balance-analysis","text":"One of the most common analysis methods for GEMs is flux balance analysis (FBA). This page will briefly walk through the basics of using FBA with Human-GEM. Important You must have a linear optimization solver (e.g., Gurobi) installed and accessible by MATLAB to run FBA. See the installation page of this guide or the RAVEN instructions for details on setting up a solver.","title":"Flux Balance Analysis"},{"location":"flux_balance_analysis/#optimization-objective","text":"By default, the model objective (defined by the .c model field) is set to maximize flux through the generic human biomass reaction ( MAR13082 ), and all exchange reactions are open. ihuman.rxns(ihuman.c == 1) % ans = % % 1\u00d71 cell array % % {'MAR13082'}","title":"Optimization objective"},{"location":"flux_balance_analysis/#run-fba","text":"Run FBA using the RAVEN solveLP function. sol = solveLP(ihuman) % sol = % % struct with fields: % % x: [13070\u00d71 double] % f: -187.3536 % stat: 1 % msg: 'Optimal solution found' The sol.f field contains the (negative) value of the objective, and the sol.x vector contains the flux value for each reaction. Important As mentioned, all the exchange reactions are fully opened (upper and lower bounds set to 1000 and -1000, respectively). Therefore, the value of the biomass flux here is meaningless (except that it is nonzero), and its units are undefined. Additional constraints, such as those defining the flux bounds of exchange reactions, are necessary to define a feasible solution space.","title":"Run FBA"},{"location":"flux_balance_analysis/#an-fba-example","text":"","title":"An FBA example"},{"location":"flux_balance_analysis/#calculation-of-atp-yield","text":"To illustrate an example of a more meaningful flux solution, we can use FBA to calculate ATP yield (more specifically, the amount of ADP phosphorylated) per glucose consumed. ATP yield can be quantified by the amount of flux through the ATP hydrolysis reaction MAR03964 . constructEquations(ihuman, 'MAR03964') % ans = % % 1\u00d71 cell array % % {'ATP[c] + H2O[c] => ADP[c] + H+[c] + Pi[c]'} Change the objective to maximize flux through the ATP hydrolysis reaction: ihuman = setParam(ihuman, 'obj', 'MAR03964', 1); Prevent import of all metabolites except glucose, for which the max import flux is set to 1 (mmol/gDW/h): ihuman = setExchangeBounds(ihuman, 'glucose', -1); % negative flux indicates import Note By default, the setExchangeBounds function allows unrestricted export of all metabolites. The import of all metabolites is blocked, except for the metabolites specified in the input argument. Now perform FBA to determine the maximum amount of ATP hydrolyzed (ADP phosphorylated) per equivalent of glucose consumed. sol = solveLP(ihuman) % sol = % % struct with fields: % % x: [13070\u00d71 double] % f: -2 % stat: 1 % msg: 'Optimal solution found' As expected, the theoretical mol ADP phosphorylated per mol glucose consumed is 2. Note that we have not allowed the import of oxygen, so this is under anaerobic conditions. This is of course purely theoretical given that most humans produce very little of anything when deprived of oxygen. Let us now calculate the same ATP yield, but in the present of oxygen. We first need to update the exchange constraints: ihuman = setExchangeBounds(ihuman, {'glucose', 'O2'}, [-1, -1000]); Note that we are allowing effectively infinite oxygen consumption, since we are interested in non-O2-limited ATP yield per glucose. Now re-run the FBA to see how the maximum yield has changed: sol = solveLP(ihuman) % sol = % % struct with fields: % % x: [13070\u00d71 double] % f: -31.5000 % stat: 1 % msg: 'Optimal solution found' We now see a much higher ATP yield per glucose consumed of 31.5.","title":"Calculation of ATP yield"},{"location":"gem_comparison/","text":"Structural and functional comparison of GEMs A useful approach in comparing the metabolic network of different tissues or cell types is to compare their corresponding GEMs. There are many ways in which the structure and function of different GEMs can be compared, but this guide will focus on an approach similar to that employed in the Human-GEM publication . Important The model comparison approach presented here only applies to GEMs that were extracted from the same reference GEM, such that they share the same namespace (i.e., same reaction, metabolite, and gene ID types). Prepare the GEMs To demonstrate some model comparison methods, we will present an example based on the Human-GEM publication. The data and GEMs can be retrieved from the Zenodo repository associated with the publication. Load the .mat file containing the tissue-specific GEMs that were extracted using GTEx RNA-Seq profiles. % replace '/my/path/' with the actual path on your machine load('/my/path/tINIT_GEMs/run_tINIT_outputs/GTEx/tINIT_GTEx_outputs.mat'); The tINIT_GTEx_outputs.mat will be loaded as a structure named INIT_output . INIT_output % INIT_output = % % struct with fields: % % id: {30\u00d71 cell} % model: {30\u00d71 cell} Note A cell array of models such as the one in the model field of the INIT_output structure can be generated by models = {liverGEM; lungGEM; kidneyGEM; ... }; , where each GEM is a separate extracted model to be compared. Extract the fields as separate variables. model_ids = INIT_output.id; models = INIT_output.model; For convenience, the model ID for each GEM was extracted and saved as a cell array in the id field of the INIT_output structure. However, this can be regenerated from the model array: model_ids = arrayfun(@(i) models{i}.id, (1:numel(models))', 'UniformOutput', false); Compare GEM structures The RAVEN compareMultipleModels function can be used to compare some basic features of different models such as reaction content and subsystem coverage. Call the comparison function with the model array models as input. res = compareMultipleModels(models); % Getting model IDs % *** Done % % % Comparing subsystem utilization % *** Done % % % Comparing model reaction correlations % *** Done % % % Comparing model reaction structures % *** Done Take a look at the contents of the results structure res . res % res = % % struct with fields: % % modelIDs: {30\u00d71 cell} % subsystems: [1\u00d71 struct] % reactions: [1\u00d71 struct] % structComp: [30\u00d730 double] % structCompMap: [30\u00d73 double] Detail on the meaning of each output can be found in the compareMultipleModels function description (view using help compareMultipleModels ), but a brief overview is provided here: Field Subfield Description modelIDs -- List of GEM IDs subsystems ID List of subsystem IDs corresponding to rows in matrix subfield matrix Number of reactions in each subsystem for each GEM reactions IDs List of reaction IDs corresponding to rows in matrix subfield matrix Binary matrix denoting presence (1) or absence (0) of each reaction in each GEM structComp -- Hamming similarity of reaction content between each pair of GEMs structCompMap -- Reduced dimension (tSNE) mapping of GEMs based on the Hamming distances of their reaction content The compareMultipleModels function represents the reaction content of each GEM as a binary vector (missing reactions are 0, present reactions are 1) to enable the use of quantitative comparison metrics, such as Hamming distance. GEMs that share fewer reactions will be separated by a larger Hamming distance, whereas GEMs that contain many of the same reactions will exhibit a small Hamming distance. Visualize the reaction content Hamming similarity (1 - Hamming distance) among the GEMs using a clustergram. clustergram(res.structComp, 'Symmetric', false, 'Colormap', 'bone', 'RowLabels', res.modelIDs, 'ColumnLabels', res.modelIDs); Note Given the generally poor plotting capabilities and limited color palette options in MATLAB, an option is to export the res.structComp matrix and/or other results to a csv or text file and import them into R, python, or some other package with more plotting flexibility. The structCompMap field of the model comparison results structure contains a mapping of the GEMs' binary reaction vectors in reduced (3) dimensions using tSNE. Since 3D plots can be difficult to interpret, we can regenerate the mapping in 2 dimensions. rxn2Dmap = tsne(res.reactions.matrix', 'Distance', 'hamming', 'NumDimensions', 2, 'Perplexity', 5); % plot and label the GEMs in tSNE space scatter(rxn2Dmap(:,1), rxn2Dmap(:,2)); hold on text(rxn2Dmap(:,1), rxn2Dmap(:,2), res.modelIDs); The Hamming distance heatmap and tSNE projection give an overall picture of how similar or different models are from one another, but it does not resolve the cause or biological meaning of those differences. A convenient source of biological context is the subSystems field in the model, which describes the metabolic subsystem or pathway to which reactions belong. We can therefore look at differences in reaction content in each of these subsystems to see which parts of metabolism differ most among the GEMs. To simplify the interpretation of results, select a subset of GEMs to analyze further. useModels = {'adipose tissue', 'blood', 'kidney', 'liver', 'muscle'}; keep = ismember(res.modelIDs, useModels); subMat = res.subsystems.matrix(:, keep); Calculate the percent difference of GEM subsystem coverage (number of reactions in the subsystem) from the mean coverage. subCoverage = (subMat - mean(subMat, 2)) ./ mean(subMat, 2) * 100; Visualize the difference in subsystem coverage with a clustergram, including only subsystems with at least a 25% difference in one or more GEMs. % select subsystems to include in plot inclSub = any(abs(subCoverage) > 25, 2); subNames = res.subsystems.ID(inclSub); % generate clustergram cg = clustergram(subCoverage(inclSub,:), 'Colormap', redbluecmap, 'DisplayRange', 100, 'rowLabels', subNames, 'columnLabels', useModels, 'ShowDendrogram', 'OFF'); Tip The clustergram function is very limited in how the produced heatmap can be modified. After running the cg = clustergram(...) command, close the figure and use plot(cg) to render a new version of the heatmap that has more editing options. Compare GEM functions In addition to GEM structure, the functionality of GEMs can be compared to provide insight into differences in their metabolic activity. One way in which the function of a GEM can be assessed is by evaluating its ability to perform different metabolic tasks. The GTEx tissue GEMs used in this example were generated using tINIT with a list of 57 essential tasks (see the GEM extraction section of this guide for details). Therefore, comparing the GEMs' ability to complete these 57 tasks would be highly uninteresting because they were all generated with the requirement that these tasks are functional. For a more interesting comparison, we will instead use a different list of 256 metabolic tasks. To speed up the calculation and to narrow the focus, we will include only a few of the GEMs in this comparison. useModels = {'adipose tissue', 'blood', 'kidney', 'liver', 'muscle'}; keep = ismember(res.modelIDs, useModels); The larger metabolic task file metabolicTasks_Full.xlsx can be found in the /data/metabolicTasks/ subdirectory of the Human-GEM repository. % replace '/my/path/' with the actual path on your machine taskFileName = '/my/path/Human-GEM/data/metabolicTasks/metabolicTasks_Full.xlsx'; Re-run the compareMultipleModels function, now including the location of the metabolic task file. res_func = compareMultipleModels(models(keep), false, false, [], true, taskFile); % Getting model IDs % *** Done % % % Comparing subsystem utilization % *** Done % % % Comparing model reaction correlations % *** Done % % % Comparing model reaction structures % *** Done % % % Checking model performance on specified tasks. % % Checking model # 1 % ERROR: Could not find all inputs in \"[71] Cystine de novo synthesis (minimal substrates, minimal excretion)\" % % Checking model # 2 % ERROR: Could not find all inputs in \"[71] Cystine de novo synthesis (minimal substrates, minimal excretion)\" % ERROR: Could not find all outputs in \"[103] Heme de novo synthesis (minimal substrates, physiological excretion)\" % ERROR: Could not find all inputs in \"[249] Bilirubin conjugation (minimal substrates, physiological excretion)\" % % Checking model # 3 % ERROR: Could not find all inputs in \"[71] Cystine de novo synthesis (minimal substrates, minimal excretion)\" % % Checking model # 4 % ERROR: Could not find all inputs in \"[71] Cystine de novo synthesis (minimal substrates, minimal excretion)\" % % Checking model # 5 % ERROR: Could not find all inputs in \"[71] Cystine de novo synthesis (minimal substrates, minimal excretion)\" % ERROR: Could not find all inputs in \"[249] Bilirubin conjugation (minimal substrates, physiological excretion)\" % *** Done Note The ERROR messages here are not actual errors, but indicate that a task was failed because the GEM was missing one or more metabolites involved in the test. The results structure will now have an additional funcComp field. res_func.funcComp % ans = % % struct with fields: % % matrix: [256\u00d75 double] % tasks: {256\u00d71 cell} The matrix subfield is a binary matrix indicating whether each task passed (1) or failed (0) in each GEM, and the tasks subfield contains the name of the evaluated tasks. Identify which tasks differed among the GEMs (i.e., not all passed or all failed). isDiff = ~all(res_func.funcComp.matrix == 0, 2) & ~all(res_func.funcComp.matrix == 1, 2); diffTasks = res_func.funcComp.tasks(isDiff) % diffTasks = % % 18\u00d71 cell array % % {'ATP salvage from Hypoxanthine' } % {'Gluconeogenesis from Alanine' } % {'Arginine de novo synthesis (minimal substrates, minimal excretion)' } % {'Glycine de novo synthesis (minimal substrates, minimal excretion)' } % {'Proline de novo synthesis (minimal substrates, minimal excretion)' } % {'Tyrosine de novo synthesis (minimal substrates with AA, minimal excretion)' } % {'Ornithine degradation' } % {'Urea from alanine' } % {'Urea from glutamine' } % {'Creatine de novo synthesis (minimal substrates, physiological excretion)' } % {'Heme de novo synthesis (minimal substrates, physiological excretion)' } % {'NAD de novo synthesis (minimal substrates, physiological excretion)' } % {'NADP de novo synthesis (minimal substrates, physiological excretion)' } % {'Acetoacetate de novo synthesis' } % {'DHA de novo synthesis (minimal substrates, physiological excretion)' } % {'Taurocholate de novo synthesis and excretion (minimal substrates, physiological excretion)'} % {'Bilirubin conjugation (minimal substrates, physiological excretion)' } % {'NH3 import and degradation' } Generate a scatter plot to visualize GEM performance on the subset of tasks that differed. % visualize the matrix spy(res_func.funcComp.matrix(isDiff,:), 30); % apply some formatting changes set(gca, 'XTick', 1:numel(useModels), 'XTickLabel', useModels, 'XTickLabelRotation', 90, ... 'YTick', 1:numel(diffTasks), 'YTickLabel', diffTasks, 'YAxisLocation', 'right'); xlabel(gca, '');","title":"GEM comparison"},{"location":"gem_comparison/#structural-and-functional-comparison-of-gems","text":"A useful approach in comparing the metabolic network of different tissues or cell types is to compare their corresponding GEMs. There are many ways in which the structure and function of different GEMs can be compared, but this guide will focus on an approach similar to that employed in the Human-GEM publication . Important The model comparison approach presented here only applies to GEMs that were extracted from the same reference GEM, such that they share the same namespace (i.e., same reaction, metabolite, and gene ID types).","title":"Structural and functional comparison of GEMs"},{"location":"gem_comparison/#prepare-the-gems","text":"To demonstrate some model comparison methods, we will present an example based on the Human-GEM publication. The data and GEMs can be retrieved from the Zenodo repository associated with the publication. Load the .mat file containing the tissue-specific GEMs that were extracted using GTEx RNA-Seq profiles. % replace '/my/path/' with the actual path on your machine load('/my/path/tINIT_GEMs/run_tINIT_outputs/GTEx/tINIT_GTEx_outputs.mat'); The tINIT_GTEx_outputs.mat will be loaded as a structure named INIT_output . INIT_output % INIT_output = % % struct with fields: % % id: {30\u00d71 cell} % model: {30\u00d71 cell} Note A cell array of models such as the one in the model field of the INIT_output structure can be generated by models = {liverGEM; lungGEM; kidneyGEM; ... }; , where each GEM is a separate extracted model to be compared. Extract the fields as separate variables. model_ids = INIT_output.id; models = INIT_output.model; For convenience, the model ID for each GEM was extracted and saved as a cell array in the id field of the INIT_output structure. However, this can be regenerated from the model array: model_ids = arrayfun(@(i) models{i}.id, (1:numel(models))', 'UniformOutput', false);","title":"Prepare the GEMs"},{"location":"gem_comparison/#compare-gem-structures","text":"The RAVEN compareMultipleModels function can be used to compare some basic features of different models such as reaction content and subsystem coverage. Call the comparison function with the model array models as input. res = compareMultipleModels(models); % Getting model IDs % *** Done % % % Comparing subsystem utilization % *** Done % % % Comparing model reaction correlations % *** Done % % % Comparing model reaction structures % *** Done Take a look at the contents of the results structure res . res % res = % % struct with fields: % % modelIDs: {30\u00d71 cell} % subsystems: [1\u00d71 struct] % reactions: [1\u00d71 struct] % structComp: [30\u00d730 double] % structCompMap: [30\u00d73 double] Detail on the meaning of each output can be found in the compareMultipleModels function description (view using help compareMultipleModels ), but a brief overview is provided here: Field Subfield Description modelIDs -- List of GEM IDs subsystems ID List of subsystem IDs corresponding to rows in matrix subfield matrix Number of reactions in each subsystem for each GEM reactions IDs List of reaction IDs corresponding to rows in matrix subfield matrix Binary matrix denoting presence (1) or absence (0) of each reaction in each GEM structComp -- Hamming similarity of reaction content between each pair of GEMs structCompMap -- Reduced dimension (tSNE) mapping of GEMs based on the Hamming distances of their reaction content The compareMultipleModels function represents the reaction content of each GEM as a binary vector (missing reactions are 0, present reactions are 1) to enable the use of quantitative comparison metrics, such as Hamming distance. GEMs that share fewer reactions will be separated by a larger Hamming distance, whereas GEMs that contain many of the same reactions will exhibit a small Hamming distance. Visualize the reaction content Hamming similarity (1 - Hamming distance) among the GEMs using a clustergram. clustergram(res.structComp, 'Symmetric', false, 'Colormap', 'bone', 'RowLabels', res.modelIDs, 'ColumnLabels', res.modelIDs); Note Given the generally poor plotting capabilities and limited color palette options in MATLAB, an option is to export the res.structComp matrix and/or other results to a csv or text file and import them into R, python, or some other package with more plotting flexibility. The structCompMap field of the model comparison results structure contains a mapping of the GEMs' binary reaction vectors in reduced (3) dimensions using tSNE. Since 3D plots can be difficult to interpret, we can regenerate the mapping in 2 dimensions. rxn2Dmap = tsne(res.reactions.matrix', 'Distance', 'hamming', 'NumDimensions', 2, 'Perplexity', 5); % plot and label the GEMs in tSNE space scatter(rxn2Dmap(:,1), rxn2Dmap(:,2)); hold on text(rxn2Dmap(:,1), rxn2Dmap(:,2), res.modelIDs); The Hamming distance heatmap and tSNE projection give an overall picture of how similar or different models are from one another, but it does not resolve the cause or biological meaning of those differences. A convenient source of biological context is the subSystems field in the model, which describes the metabolic subsystem or pathway to which reactions belong. We can therefore look at differences in reaction content in each of these subsystems to see which parts of metabolism differ most among the GEMs. To simplify the interpretation of results, select a subset of GEMs to analyze further. useModels = {'adipose tissue', 'blood', 'kidney', 'liver', 'muscle'}; keep = ismember(res.modelIDs, useModels); subMat = res.subsystems.matrix(:, keep); Calculate the percent difference of GEM subsystem coverage (number of reactions in the subsystem) from the mean coverage. subCoverage = (subMat - mean(subMat, 2)) ./ mean(subMat, 2) * 100; Visualize the difference in subsystem coverage with a clustergram, including only subsystems with at least a 25% difference in one or more GEMs. % select subsystems to include in plot inclSub = any(abs(subCoverage) > 25, 2); subNames = res.subsystems.ID(inclSub); % generate clustergram cg = clustergram(subCoverage(inclSub,:), 'Colormap', redbluecmap, 'DisplayRange', 100, 'rowLabels', subNames, 'columnLabels', useModels, 'ShowDendrogram', 'OFF'); Tip The clustergram function is very limited in how the produced heatmap can be modified. After running the cg = clustergram(...) command, close the figure and use plot(cg) to render a new version of the heatmap that has more editing options.","title":"Compare GEM structures"},{"location":"gem_comparison/#compare-gem-functions","text":"In addition to GEM structure, the functionality of GEMs can be compared to provide insight into differences in their metabolic activity. One way in which the function of a GEM can be assessed is by evaluating its ability to perform different metabolic tasks. The GTEx tissue GEMs used in this example were generated using tINIT with a list of 57 essential tasks (see the GEM extraction section of this guide for details). Therefore, comparing the GEMs' ability to complete these 57 tasks would be highly uninteresting because they were all generated with the requirement that these tasks are functional. For a more interesting comparison, we will instead use a different list of 256 metabolic tasks. To speed up the calculation and to narrow the focus, we will include only a few of the GEMs in this comparison. useModels = {'adipose tissue', 'blood', 'kidney', 'liver', 'muscle'}; keep = ismember(res.modelIDs, useModels); The larger metabolic task file metabolicTasks_Full.xlsx can be found in the /data/metabolicTasks/ subdirectory of the Human-GEM repository. % replace '/my/path/' with the actual path on your machine taskFileName = '/my/path/Human-GEM/data/metabolicTasks/metabolicTasks_Full.xlsx'; Re-run the compareMultipleModels function, now including the location of the metabolic task file. res_func = compareMultipleModels(models(keep), false, false, [], true, taskFile); % Getting model IDs % *** Done % % % Comparing subsystem utilization % *** Done % % % Comparing model reaction correlations % *** Done % % % Comparing model reaction structures % *** Done % % % Checking model performance on specified tasks. % % Checking model # 1 % ERROR: Could not find all inputs in \"[71] Cystine de novo synthesis (minimal substrates, minimal excretion)\" % % Checking model # 2 % ERROR: Could not find all inputs in \"[71] Cystine de novo synthesis (minimal substrates, minimal excretion)\" % ERROR: Could not find all outputs in \"[103] Heme de novo synthesis (minimal substrates, physiological excretion)\" % ERROR: Could not find all inputs in \"[249] Bilirubin conjugation (minimal substrates, physiological excretion)\" % % Checking model # 3 % ERROR: Could not find all inputs in \"[71] Cystine de novo synthesis (minimal substrates, minimal excretion)\" % % Checking model # 4 % ERROR: Could not find all inputs in \"[71] Cystine de novo synthesis (minimal substrates, minimal excretion)\" % % Checking model # 5 % ERROR: Could not find all inputs in \"[71] Cystine de novo synthesis (minimal substrates, minimal excretion)\" % ERROR: Could not find all inputs in \"[249] Bilirubin conjugation (minimal substrates, physiological excretion)\" % *** Done Note The ERROR messages here are not actual errors, but indicate that a task was failed because the GEM was missing one or more metabolites involved in the test. The results structure will now have an additional funcComp field. res_func.funcComp % ans = % % struct with fields: % % matrix: [256\u00d75 double] % tasks: {256\u00d71 cell} The matrix subfield is a binary matrix indicating whether each task passed (1) or failed (0) in each GEM, and the tasks subfield contains the name of the evaluated tasks. Identify which tasks differed among the GEMs (i.e., not all passed or all failed). isDiff = ~all(res_func.funcComp.matrix == 0, 2) & ~all(res_func.funcComp.matrix == 1, 2); diffTasks = res_func.funcComp.tasks(isDiff) % diffTasks = % % 18\u00d71 cell array % % {'ATP salvage from Hypoxanthine' } % {'Gluconeogenesis from Alanine' } % {'Arginine de novo synthesis (minimal substrates, minimal excretion)' } % {'Glycine de novo synthesis (minimal substrates, minimal excretion)' } % {'Proline de novo synthesis (minimal substrates, minimal excretion)' } % {'Tyrosine de novo synthesis (minimal substrates with AA, minimal excretion)' } % {'Ornithine degradation' } % {'Urea from alanine' } % {'Urea from glutamine' } % {'Creatine de novo synthesis (minimal substrates, physiological excretion)' } % {'Heme de novo synthesis (minimal substrates, physiological excretion)' } % {'NAD de novo synthesis (minimal substrates, physiological excretion)' } % {'NADP de novo synthesis (minimal substrates, physiological excretion)' } % {'Acetoacetate de novo synthesis' } % {'DHA de novo synthesis (minimal substrates, physiological excretion)' } % {'Taurocholate de novo synthesis and excretion (minimal substrates, physiological excretion)'} % {'Bilirubin conjugation (minimal substrates, physiological excretion)' } % {'NH3 import and degradation' } Generate a scatter plot to visualize GEM performance on the subset of tasks that differed. % visualize the matrix spy(res_func.funcComp.matrix(isDiff,:), 30); % apply some formatting changes set(gca, 'XTick', 1:numel(useModels), 'XTickLabel', useModels, 'XTickLabelRotation', 90, ... 'YTick', 1:numel(diffTasks), 'YTickLabel', diffTasks, 'YAxisLocation', 'right'); xlabel(gca, '');","title":"Compare GEM functions"},{"location":"gem_extraction/","text":"GEM Extraction Human-GEM is a generic model of human metabolism, meaning that it contains metabolic reactions known to occur in any human cell. The model is therefore not representative of any one tissue or cell type, in which only a subset of the reactions would be active. A common approach is to extract the subset of the GEM that is likely to be active in the tissue or cell type of interest, based on a corresponding dataset (e.g., transcriptomics, proteomics, metabolomics, etc.). This approach is often referred to as GEM extraction or contextualization , where the generated model is termed the extracted or contextualized / context-specific GEM . Fast Task\u2010driven Integrative Network Inference for Tissues (ftINIT) Although many GEM extraction methods exist, this guide will cover the ftINIT algorithm. For more details on the algorithm, see the following papers: Agren et al. (2012) PLoS Comput Biol - Initial development of INIT Agren et al. (2014) Mol Syst Biol - Incorporation of metabolic tasks (tINIT) Robinson et al. (2020) Sci Signal - Recognition of enzyme complexes Gustafsson et al. (2022) BioRXiv - ftINIT, faster and produces less gaps in the models The ftINIT algorithm is available in the RAVEN Toolbox, and we use it together with help functions for Human-GEM available in the Human-GEM repository. To support users of the previous algorithm (tINIT), we also include a guide for the previous (2020) version of tINIT, called the getINITModel2 function. Retrieve the data To demonstrate the use of ftINIT, we will walk through an example where we generate models from GTEx data. For simplicity, we extracted 60 RNA-Seq profiles from in total 12 tissues. The data can be downloaded here together with other data useful for this tutorial. Download the Zenodo repository .zip file, and extract. Load and prepare the reference model for use with ftINIT The reference GEM from which the tissue-specific models will be extracted is Human-GEM. Load the model from the Human-GEM.mat file in the Human-GEM repository load('Human-GEM.mat'); % loads model as a structure named \"ihuman\" ftINIT has a preparation step that needs to be run once for a reference model such as Human-GEM. The purpose of the preparation step is to make calculations in advance to reduce the time it takes to generate each context-specific model. The result is a prepData structure that contains various information needed by ftINIT. This operation takes 1-2 hours on a standard laptop computer, so make sure to save it once it has completed. For version 1.12.0 of Human-GEM, the prepData is available in the Zenodo .zip file. % The second flag indicates if the model should be converted to gene symbols from ENSEMBL. This has to be decided at this point. prepData = prepHumanModelForftINIT(ihuman, false); save('prepData.mat', 'prepData') prepHumanModelForftINIT tests that the reference model (Human-GEM) can successfully perform all essential metabolic tasks (defined in data/metabolicTasks/metabolicTasks_Essential.txt ), which is an important step. If the reference model cannot perform a task, then neither can any GEM extracted from that model. Note The exchange reactions should all be unbounded (e.g., lower and upper bounds of -1000 and 1000, respectively). Human-GEM is already provided in this format, so no additional changes are needed. Note The function prepHumanModelForftINIT will automatically use the essential tasks from metabolicTasks_Essential.txt in the Human-GEM repository. To specify different metabolic tasks, use prepINITModel in RAVEN directly instead. Prepare the transcriptomic data Data from the condition, tissue, or cell type for which the GEM will be generated is necessary to determine which reactions from the reference model (Human-GEM) should be included. In this case, we use a file with tissues extracted from the GTEx database, which is available in the Zenodo .zip file. In MATLAB, load the gtexSampForTutorialTPM.txt file from the Zenodo repository. % replace 'my/path/' with the path on your system, or change to the directory containing the file gtex_data = readtable('my/path/gtexSampForTutorialTPM.txt'); [~, n] = size(gtex_data); numSamp = n-2; %the first two columns are the genes in ENSEMBL and gene symbols format % take a look at the first few rows and columns of the table gtex_data(1:5, 1:5) % ans = % % 5\u00d75 table % % Name Description GTEX_111YS_0006_SM_5NQBE GTEX_1122O_0005_SM_5O99J GTEX_1128S_0005_SM_5P9HI % ___________________ _______________ ________________________ ________________________ ________________________ % % {'ENSG00000223972'} {'DDX11L1' } 0.02171 0.03015 0.0203 % {'ENSG00000227232'} {'WASH7P' } 1.555 2.747 4.441 % {'ENSG00000278267'} {'MIR6859-1' } 0 0 0 % {'ENSG00000243485'} {'MIR1302-2HG'} 0 0 0 % {'ENSG00000237613'} {'FAM138A' } 0 0 0.0576 Extract information from the table into a structure called data_struct % extract the tissue and gene names data_struct.genes = gtex_data{:, 1}; % gene names data_struct.tissues = gtex_data.Properties.VariableNames(3:n); % sample (tissue) names data_struct.levels = gtex_data{:, 3:n}; % gene TPM values Important The name of the data structure ( data_struct in this example) is not important. However, its fields ( genes , tissues , levels ) should not be changed. Although the original tINIT implementation always compared gene expression in the tissue of interest to the average of all other provided tissues, ftINIT enables the option to instead compare the expression to a threshold value. Here, we will use this alternative approach with a threshold value of 1 TPM. data_struct.threshold = 1; Note Exclude the threshold field from the data structure to use the original tINIT approach of comparing the gene expression in your tissue of interest with all other tissues. If you choose this approach, however, you must include the gene expression data from the other tissues so that the algorithm has something to compare to. Take a look at data_struct to make sure all the fields are present and have the expected dimensions data_struct % data_struct = % % struct with fields: % % genes: {56200\u00d71 cell} % tissues: {1\u00d760 cell} % levels: [56200\u00d760 double] % threshold: 1 Run ftINIT Now all inputs are ready to run ftINIT and extract GEMs specific to the samples based on their corresponding RNA expression profile. ftINIT normally runs in two steps, of which the second is optional. The first step excludes most of the reactions without gene rules (GPRs) from the problem, and the second step determines which of those reactions should be removed. The second step can be omitted, which causes most reactions without GPRs to remain in the model. This is a good option in many cases, for example for structural comparison of models, since removal of reactions without GPRs does not provide any additional information and may add randomness in cases where there are several equally good solutions. We first run ftINIT without the second step, a setup that is called '1+0' , which typically takes 30 - 60 seconds: model1 = ftINIT(prepData, data_struct.tissues{1}, [], [], data_struct, {}, getHumanGEMINITSteps('1+0'), false, true); model1 % % struct with fields: % % id: 'Human-GEM' % description: 'Generic genome-scale metabolic model of Homo sapiens' % rxns: {8407\u00d71 cell} % mets: {5613\u00d71 cell} % S: [5613\u00d78407 double] % lb: [8407\u00d71 double] % ub: [8407\u00d71 double] % rev: [8407\u00d71 double] % c: [8407\u00d71 double] % b: [5613\u00d71 double] % comps: {9\u00d71 cell} % compNames: {9\u00d71 cell} % rxnNames: {8407\u00d71 cell} % grRules: {8407\u00d71 cell} % rxnGeneMat: [8407\u00d72494 double] % subSystems: {8407\u00d71 cell} % eccodes: {8407\u00d71 cell} % rxnNotes: {8407\u00d71 cell} % genes: {2494\u00d71 cell} % metNames: {5613\u00d71 cell} % metComps: [5613\u00d71 double] % inchis: {5613\u00d71 cell} % metFormulas: {5613\u00d71 cell} % rxnReferences: {8407\u00d71 cell} % rxnFrom: {8407\u00d71 cell} % metFrom: {5613\u00d71 cell} % rxnConfidenceScores: [8407\u00d71 double] % metCharges: [5613\u00d71 int64] % version: '1.12.0' % annotation: [1\u00d71 struct] As an alternative, we can run it with the second step included ( '1+1' ), which takes roughly 2 - 3 times as long and generates a smaller model: model2 = ftINIT(prepData, data_struct.tissues{1}, [], [], data_struct, {}, getHumanGEMINITSteps('1+1'), false, true); model2 % % struct with fields: % % id: 'Human-GEM' % description: 'Generic genome-scale metabolic model of Homo sapiens' % rxns: {7752\u00d71 cell} % mets: {5490\u00d71 cell} % S: [5490\u00d77752 double] % lb: [7752\u00d71 double] % ub: [7752\u00d71 double] % rev: [7752\u00d71 double] % c: [7752\u00d71 double] % b: [5490\u00d71 double] % comps: {9\u00d71 cell} % compNames: {9\u00d71 cell} % rxnNames: {7752\u00d71 cell} % grRules: {7752\u00d71 cell} % rxnGeneMat: [7752\u00d72494 double] % subSystems: {7752\u00d71 cell} % eccodes: {7752\u00d71 cell} % rxnNotes: {7752\u00d71 cell} % genes: {2494\u00d71 cell} % metNames: {5490\u00d71 cell} % metComps: [5490\u00d71 double] % inchis: {5490\u00d71 cell} % metFormulas: {5490\u00d71 cell} % rxnReferences: {7752\u00d71 cell} % rxnFrom: {7752\u00d71 cell} % metFrom: {5490\u00d71 cell} % rxnConfidenceScores: [7752\u00d71 double] % metCharges: [5490\u00d71 int64] % version: '1.12.0' % annotation: [1\u00d71 struct] It is also possible to supply cell type for cases where tissues are subdivided into cell type, which is not the case here. The method also accepts proteomics data from Human Protein Atlas (HPA) and metabolomics data, but these are not demonstrated here. Note The two steps used here are the two most common approaches to run ftINIT and are what we recommend, but they are not the only options. ftINIT can for example be run in a very similar way to the original tINIT algorithm by using the 'full' setup. It is recommended to change the model id to a more descriptive name than the default of \"INITModel\". This is particularly useful when analyzing several models together. model1.id = data_struct.tissues{1}; Run ftINIT for all samples We can now run ftINIT on all samples: models = cell(numSamp, 1); for i = 1:numSamp disp(['Model: ' num2str(i) ' of ' num2str(numSamp)]) models{i} = ftINIT(prepData, data_struct.tissues{i}, [], [], data_struct, {}, getHumanGEMINITSteps('1+0'), false, true); end save('models.mat', 'models') Warning This loop generates 60 models, which will take a while to run (30 min to 1 hr). For running many models, it is therefore recommended that this is run on a compute cluster. Quick examination of the models To get a quick structural overview of the models, we perform a t-SNE (t-Distributed Stochastic Neighbor Embedding) transformation of the models' reaction content and export that data to a file for visualization in R. baseModel = prepData.refModel; % now build a matrix saying which reactions are on compMat = false(length(baseModel.rxns), length(models)); for i = 1:size(compMat,2) compMat(:,i) = ismember(baseModel.rxns,models{i}.rxns); end % run t-sne rng(1); %set random seed to make reproducible proj_coords = tsne(double(compMat.'), 'Distance', 'hamming', 'NumDimensions', 2, 'Exaggeration', 6, 'Perplexity', 10); % export to R d = struct(); d.tsneX = proj_coords(:, 1); d.tsneY = proj_coords(:, 2); save('TSNE.mat', 'd'); We can then visualize the data in R (use e.g., RStudio) using ggplot: library(R.matlab) library(tidyverse) library(ggplot2) #import the data using R.matlab setwd(\"my/path\") #replace with your own path where the exported data was saved tsneData = readMat(\"TSNE.mat\") x = as.numeric(tsneData$d[,,1]$tsneX) y = as.numeric(tsneData$d[,,1]$tsneY) #read the tissues to be able to color the models properly tissues = read_tsv('gtexSampTissuesForTutorial.txt', col_names = FALSE)[[1]] tissFact = as.factor(tissues) #set up a tibble for the plot df = tibble(x=x, y=y, tissue = tissFact) color_palette = c('#B5D39B','#E7B56C','#6B97BC','#BC976B','#BC556B','#000000') #plot the data fig = ggplot(df, aes(x = x, y = y, color=tissue, shape=tissue)) + geom_point(size=2, stroke = 2) + scale_color_manual(values = c(color_palette,color_palette), labels = levels(tissFact) ) + scale_shape_manual(values = c(19,19,19,19,19,19,0,0,0,0,0,0), labels=levels(tissFact)) + ggplot2::labs(y=expression(\"t-SNE y\"), x=\"t-SNE x\", title=\"Structural comparison\") + ggplot2::theme_bw() + ggplot2::theme(panel.background = element_rect(\"white\", \"white\", 0, 0, \"white\"), panel.grid.major= element_blank(),panel.grid.minor= element_blank()) + ggplot2::theme(legend.title = element_blank(),legend.position=\"bottom\", legend.text=element_text(size=14)) + guides(colour = guide_legend(nrow = 4), size = guide_legend(nrow = 4), linetype = guide_legend(nrow = 4)) + ggplot2::theme(text = element_text(size=14), axis.text.x = element_text(color='black', size=14), axis.text.y = element_text(color='black', size=14)) fig #export the figure to file ggsave( \"StructCompftINIT.png\", plot = fig, width = 8, height = 8, dpi = 300)","title":"GEM extraction using ftINIT"},{"location":"gem_extraction/#gem-extraction","text":"Human-GEM is a generic model of human metabolism, meaning that it contains metabolic reactions known to occur in any human cell. The model is therefore not representative of any one tissue or cell type, in which only a subset of the reactions would be active. A common approach is to extract the subset of the GEM that is likely to be active in the tissue or cell type of interest, based on a corresponding dataset (e.g., transcriptomics, proteomics, metabolomics, etc.). This approach is often referred to as GEM extraction or contextualization , where the generated model is termed the extracted or contextualized / context-specific GEM .","title":"GEM Extraction"},{"location":"gem_extraction/#fast-taskdriven-integrative-network-inference-for-tissues-ftinit","text":"Although many GEM extraction methods exist, this guide will cover the ftINIT algorithm. For more details on the algorithm, see the following papers: Agren et al. (2012) PLoS Comput Biol - Initial development of INIT Agren et al. (2014) Mol Syst Biol - Incorporation of metabolic tasks (tINIT) Robinson et al. (2020) Sci Signal - Recognition of enzyme complexes Gustafsson et al. (2022) BioRXiv - ftINIT, faster and produces less gaps in the models The ftINIT algorithm is available in the RAVEN Toolbox, and we use it together with help functions for Human-GEM available in the Human-GEM repository. To support users of the previous algorithm (tINIT), we also include a guide for the previous (2020) version of tINIT, called the getINITModel2 function.","title":"Fast Task\u2010driven Integrative Network Inference for Tissues (ftINIT)"},{"location":"gem_extraction/#retrieve-the-data","text":"To demonstrate the use of ftINIT, we will walk through an example where we generate models from GTEx data. For simplicity, we extracted 60 RNA-Seq profiles from in total 12 tissues. The data can be downloaded here together with other data useful for this tutorial. Download the Zenodo repository .zip file, and extract.","title":"Retrieve the data"},{"location":"gem_extraction/#load-and-prepare-the-reference-model-for-use-with-ftinit","text":"The reference GEM from which the tissue-specific models will be extracted is Human-GEM. Load the model from the Human-GEM.mat file in the Human-GEM repository load('Human-GEM.mat'); % loads model as a structure named \"ihuman\" ftINIT has a preparation step that needs to be run once for a reference model such as Human-GEM. The purpose of the preparation step is to make calculations in advance to reduce the time it takes to generate each context-specific model. The result is a prepData structure that contains various information needed by ftINIT. This operation takes 1-2 hours on a standard laptop computer, so make sure to save it once it has completed. For version 1.12.0 of Human-GEM, the prepData is available in the Zenodo .zip file. % The second flag indicates if the model should be converted to gene symbols from ENSEMBL. This has to be decided at this point. prepData = prepHumanModelForftINIT(ihuman, false); save('prepData.mat', 'prepData') prepHumanModelForftINIT tests that the reference model (Human-GEM) can successfully perform all essential metabolic tasks (defined in data/metabolicTasks/metabolicTasks_Essential.txt ), which is an important step. If the reference model cannot perform a task, then neither can any GEM extracted from that model. Note The exchange reactions should all be unbounded (e.g., lower and upper bounds of -1000 and 1000, respectively). Human-GEM is already provided in this format, so no additional changes are needed. Note The function prepHumanModelForftINIT will automatically use the essential tasks from metabolicTasks_Essential.txt in the Human-GEM repository. To specify different metabolic tasks, use prepINITModel in RAVEN directly instead.","title":"Load and prepare the reference model for use with ftINIT"},{"location":"gem_extraction/#prepare-the-transcriptomic-data","text":"Data from the condition, tissue, or cell type for which the GEM will be generated is necessary to determine which reactions from the reference model (Human-GEM) should be included. In this case, we use a file with tissues extracted from the GTEx database, which is available in the Zenodo .zip file. In MATLAB, load the gtexSampForTutorialTPM.txt file from the Zenodo repository. % replace 'my/path/' with the path on your system, or change to the directory containing the file gtex_data = readtable('my/path/gtexSampForTutorialTPM.txt'); [~, n] = size(gtex_data); numSamp = n-2; %the first two columns are the genes in ENSEMBL and gene symbols format % take a look at the first few rows and columns of the table gtex_data(1:5, 1:5) % ans = % % 5\u00d75 table % % Name Description GTEX_111YS_0006_SM_5NQBE GTEX_1122O_0005_SM_5O99J GTEX_1128S_0005_SM_5P9HI % ___________________ _______________ ________________________ ________________________ ________________________ % % {'ENSG00000223972'} {'DDX11L1' } 0.02171 0.03015 0.0203 % {'ENSG00000227232'} {'WASH7P' } 1.555 2.747 4.441 % {'ENSG00000278267'} {'MIR6859-1' } 0 0 0 % {'ENSG00000243485'} {'MIR1302-2HG'} 0 0 0 % {'ENSG00000237613'} {'FAM138A' } 0 0 0.0576 Extract information from the table into a structure called data_struct % extract the tissue and gene names data_struct.genes = gtex_data{:, 1}; % gene names data_struct.tissues = gtex_data.Properties.VariableNames(3:n); % sample (tissue) names data_struct.levels = gtex_data{:, 3:n}; % gene TPM values Important The name of the data structure ( data_struct in this example) is not important. However, its fields ( genes , tissues , levels ) should not be changed. Although the original tINIT implementation always compared gene expression in the tissue of interest to the average of all other provided tissues, ftINIT enables the option to instead compare the expression to a threshold value. Here, we will use this alternative approach with a threshold value of 1 TPM. data_struct.threshold = 1; Note Exclude the threshold field from the data structure to use the original tINIT approach of comparing the gene expression in your tissue of interest with all other tissues. If you choose this approach, however, you must include the gene expression data from the other tissues so that the algorithm has something to compare to. Take a look at data_struct to make sure all the fields are present and have the expected dimensions data_struct % data_struct = % % struct with fields: % % genes: {56200\u00d71 cell} % tissues: {1\u00d760 cell} % levels: [56200\u00d760 double] % threshold: 1","title":"Prepare the transcriptomic data"},{"location":"gem_extraction/#run-ftinit","text":"Now all inputs are ready to run ftINIT and extract GEMs specific to the samples based on their corresponding RNA expression profile. ftINIT normally runs in two steps, of which the second is optional. The first step excludes most of the reactions without gene rules (GPRs) from the problem, and the second step determines which of those reactions should be removed. The second step can be omitted, which causes most reactions without GPRs to remain in the model. This is a good option in many cases, for example for structural comparison of models, since removal of reactions without GPRs does not provide any additional information and may add randomness in cases where there are several equally good solutions. We first run ftINIT without the second step, a setup that is called '1+0' , which typically takes 30 - 60 seconds: model1 = ftINIT(prepData, data_struct.tissues{1}, [], [], data_struct, {}, getHumanGEMINITSteps('1+0'), false, true); model1 % % struct with fields: % % id: 'Human-GEM' % description: 'Generic genome-scale metabolic model of Homo sapiens' % rxns: {8407\u00d71 cell} % mets: {5613\u00d71 cell} % S: [5613\u00d78407 double] % lb: [8407\u00d71 double] % ub: [8407\u00d71 double] % rev: [8407\u00d71 double] % c: [8407\u00d71 double] % b: [5613\u00d71 double] % comps: {9\u00d71 cell} % compNames: {9\u00d71 cell} % rxnNames: {8407\u00d71 cell} % grRules: {8407\u00d71 cell} % rxnGeneMat: [8407\u00d72494 double] % subSystems: {8407\u00d71 cell} % eccodes: {8407\u00d71 cell} % rxnNotes: {8407\u00d71 cell} % genes: {2494\u00d71 cell} % metNames: {5613\u00d71 cell} % metComps: [5613\u00d71 double] % inchis: {5613\u00d71 cell} % metFormulas: {5613\u00d71 cell} % rxnReferences: {8407\u00d71 cell} % rxnFrom: {8407\u00d71 cell} % metFrom: {5613\u00d71 cell} % rxnConfidenceScores: [8407\u00d71 double] % metCharges: [5613\u00d71 int64] % version: '1.12.0' % annotation: [1\u00d71 struct] As an alternative, we can run it with the second step included ( '1+1' ), which takes roughly 2 - 3 times as long and generates a smaller model: model2 = ftINIT(prepData, data_struct.tissues{1}, [], [], data_struct, {}, getHumanGEMINITSteps('1+1'), false, true); model2 % % struct with fields: % % id: 'Human-GEM' % description: 'Generic genome-scale metabolic model of Homo sapiens' % rxns: {7752\u00d71 cell} % mets: {5490\u00d71 cell} % S: [5490\u00d77752 double] % lb: [7752\u00d71 double] % ub: [7752\u00d71 double] % rev: [7752\u00d71 double] % c: [7752\u00d71 double] % b: [5490\u00d71 double] % comps: {9\u00d71 cell} % compNames: {9\u00d71 cell} % rxnNames: {7752\u00d71 cell} % grRules: {7752\u00d71 cell} % rxnGeneMat: [7752\u00d72494 double] % subSystems: {7752\u00d71 cell} % eccodes: {7752\u00d71 cell} % rxnNotes: {7752\u00d71 cell} % genes: {2494\u00d71 cell} % metNames: {5490\u00d71 cell} % metComps: [5490\u00d71 double] % inchis: {5490\u00d71 cell} % metFormulas: {5490\u00d71 cell} % rxnReferences: {7752\u00d71 cell} % rxnFrom: {7752\u00d71 cell} % metFrom: {5490\u00d71 cell} % rxnConfidenceScores: [7752\u00d71 double] % metCharges: [5490\u00d71 int64] % version: '1.12.0' % annotation: [1\u00d71 struct] It is also possible to supply cell type for cases where tissues are subdivided into cell type, which is not the case here. The method also accepts proteomics data from Human Protein Atlas (HPA) and metabolomics data, but these are not demonstrated here. Note The two steps used here are the two most common approaches to run ftINIT and are what we recommend, but they are not the only options. ftINIT can for example be run in a very similar way to the original tINIT algorithm by using the 'full' setup. It is recommended to change the model id to a more descriptive name than the default of \"INITModel\". This is particularly useful when analyzing several models together. model1.id = data_struct.tissues{1};","title":"Run ftINIT"},{"location":"gem_extraction/#run-ftinit-for-all-samples","text":"We can now run ftINIT on all samples: models = cell(numSamp, 1); for i = 1:numSamp disp(['Model: ' num2str(i) ' of ' num2str(numSamp)]) models{i} = ftINIT(prepData, data_struct.tissues{i}, [], [], data_struct, {}, getHumanGEMINITSteps('1+0'), false, true); end save('models.mat', 'models') Warning This loop generates 60 models, which will take a while to run (30 min to 1 hr). For running many models, it is therefore recommended that this is run on a compute cluster.","title":"Run ftINIT for all samples"},{"location":"gem_extraction/#quick-examination-of-the-models","text":"To get a quick structural overview of the models, we perform a t-SNE (t-Distributed Stochastic Neighbor Embedding) transformation of the models' reaction content and export that data to a file for visualization in R. baseModel = prepData.refModel; % now build a matrix saying which reactions are on compMat = false(length(baseModel.rxns), length(models)); for i = 1:size(compMat,2) compMat(:,i) = ismember(baseModel.rxns,models{i}.rxns); end % run t-sne rng(1); %set random seed to make reproducible proj_coords = tsne(double(compMat.'), 'Distance', 'hamming', 'NumDimensions', 2, 'Exaggeration', 6, 'Perplexity', 10); % export to R d = struct(); d.tsneX = proj_coords(:, 1); d.tsneY = proj_coords(:, 2); save('TSNE.mat', 'd'); We can then visualize the data in R (use e.g., RStudio) using ggplot: library(R.matlab) library(tidyverse) library(ggplot2) #import the data using R.matlab setwd(\"my/path\") #replace with your own path where the exported data was saved tsneData = readMat(\"TSNE.mat\") x = as.numeric(tsneData$d[,,1]$tsneX) y = as.numeric(tsneData$d[,,1]$tsneY) #read the tissues to be able to color the models properly tissues = read_tsv('gtexSampTissuesForTutorial.txt', col_names = FALSE)[[1]] tissFact = as.factor(tissues) #set up a tibble for the plot df = tibble(x=x, y=y, tissue = tissFact) color_palette = c('#B5D39B','#E7B56C','#6B97BC','#BC976B','#BC556B','#000000') #plot the data fig = ggplot(df, aes(x = x, y = y, color=tissue, shape=tissue)) + geom_point(size=2, stroke = 2) + scale_color_manual(values = c(color_palette,color_palette), labels = levels(tissFact) ) + scale_shape_manual(values = c(19,19,19,19,19,19,0,0,0,0,0,0), labels=levels(tissFact)) + ggplot2::labs(y=expression(\"t-SNE y\"), x=\"t-SNE x\", title=\"Structural comparison\") + ggplot2::theme_bw() + ggplot2::theme(panel.background = element_rect(\"white\", \"white\", 0, 0, \"white\"), panel.grid.major= element_blank(),panel.grid.minor= element_blank()) + ggplot2::theme(legend.title = element_blank(),legend.position=\"bottom\", legend.text=element_text(size=14)) + guides(colour = guide_legend(nrow = 4), size = guide_legend(nrow = 4), linetype = guide_legend(nrow = 4)) + ggplot2::theme(text = element_text(size=14), axis.text.x = element_text(color='black', size=14), axis.text.y = element_text(color='black', size=14)) fig #export the figure to file ggsave( \"StructCompftINIT.png\", plot = fig, width = 8, height = 8, dpi = 300)","title":"Quick examination of the models"},{"location":"gem_extraction_old_tINIT/","text":"GEM Extraction with tINIT (the older algorithm for extracting context-specific models) The original (2014) tINIT algorithm is implemented in the RAVEN Toolbox, where its main calling function is getINITModel . This guide is for the updated (2020) version of tINIT that is maintained on the Human-GEM repository, called the getINITModel2 function. Retrieve the data To demonstrate the use of tINIT, we will walk through an example that replicates part of the Human-GEM publication . The data used in this example can be retrieved from the Zenodo repository associated with the publication. Download the Zenodo repository .zip file, and extract. Prepare the transcriptomic data Data from the condition, tissue, or cell type for which the GEM will be generated is necessary to determine which reactions from the reference model (Human-GEM) should be included. In this case, we are using RNA-Seq data (TPM normalized) that was originally obtained from the GTEx database . In MATLAB, load the gtex_median_tissue_tpm.txt file from the Zenodo repository tINIT_GEMs/data/ subdirectory. % replace 'my/path/' with the path on your system, or change to the directory with the file gtex_data = readtable('my/path/tINIT_GEMs/data/gtex_median_tissue_tpm.txt'); % take a look at the first few rows and columns of the table gtex_data(1:5,1:5) % ans = % % 5\u00d75 table % % genes adipose_tissue adrenal_gland blood_vessel bladder % ___________________ ______________ _____________ ____________ _______ % % {'ENSG00000223972'} 0.05458 0.0746 0.04535 0.05878 % {'ENSG00000227232'} 11.2 8.023 11.99 14.24 % {'ENSG00000243485'} 0.06012 0.08179 0.05278 0.06097 % {'ENSG00000237613'} 0.03653 0.0405 0.03668 0.04113 % {'ENSG00000268020'} 0.02565 0.03479 0 0 Extract information from the table into a structure called data_struct % extract the tissue and gene names data_struct.tissues = gtex_data.Properties.VariableNames(2:end)'; % sample (tissue) names data_struct.genes = gtex_data.genes; % gene names data_struct.levels = table2array(gtex_data(:, 2:end)); % gene TPM values Important The name of the data structure ( data_struct in this example) is not important. However, its fields ( genes , tissues , levels ) should not be changed. Note We don't actually need all of the data for this example since we are only generating a model for one tissue (liver). One could instead extract only the liver column into the levels field, and included only liver in the tissues field. Although the original tINIT implementation always compared gene expression in the tissue of interest to the average of all other provided tissues, the updated version enables the option to instead compare the expression to a threshold value. Here, we will use this alternative approach with a threshold value of 1 TPM. data_struct.threshold = 1; Note Exclude the threshold field from the data structure to use the original tINIT approach of comparing the gene expression in your tissue of interest with all other tissues. If you choose this approach, however, you must include the gene expression data from the other tissues so that the algorithm has something to compare to. Take a look at data_struct to make sure all the fields are present and have the expected dimensions data_struct % data_struct = % % struct with fields: % % tissues: {30\u00d71 cell} % genes: {56202\u00d71 cell} % levels: [56202\u00d730 double] % threshold: 1 Load and prepare the reference GEM The reference GEM from which the liver-specific model will be extracted is Human-GEM. Load the model from the Human-GEM.mat file in the Human-GEM repository load('Human-GEM.mat'); % loads model as a structure named \"ihuman\" Important The metabolic task evaluation and tINIT algorithms requires that the model is provided in \"closed form\"; i.e., it contains boundary metabolites . Therefore, the boundary metabolites must be added to the GEM before proceeding. Add boundary metabolites to the model ihuman = addBoundaryMets(ihuman); % Boundary metabolites were added to 1665 reactions. % New (boundary) versions of 1665 metabolites were added to the model. Note The exchange reactions should all be unbounded (e.g., lower and upper bounds of -1000 and 1000, respectively). Human-GEM is already provided in this format, so no additional changes are needed. Prepare the metabolic task list The tINIT algorithm has the option to specify one or more metabolic tasks that the extracted model should be able to perform, such as transport of essential amino acids or production of biomass. Although task specification is not required, it is generally recommended to obtain a more functional extracted GEM, especially if it is going to be used in simulation-based analysis (e.g., FBA). Following with the procedure used in the Human-GEM manuscript, this example will use the list of 57 \"essential\" metabolic tasks that all cells are expected to be able to perform to be viable. Load the metabolicTasks_Essential.txt list of metabolic tasks from the data/metabolicTasks/ subdirectory of the Human-GEM repository using the RAVEN parseTaskList function. essentialTasks = parseTaskList('/my/path/Human-GEM/data/metabolicTasks/metabolicTasks_Essential.txt') % essentialTasks = % % 57\u00d71 struct array with fields: % % id % description % shouldFail % printFluxes % comments % inputs % LBin % UBin % outputs % LBout % UBout % equations % LBequ % UBequ % changed % LBrxn % UBrxn It is important to first verify that the reference model (Human-GEM) can successfully perform all of the tasks. If the reference model cannot perform a task, then neither can any GEM extracted from that model. Verify that the reference model passes all of the essential metabolic tasks. % see what the other inputs mean by typing \"help checkTasks\" checkTasks(ihuman, [], true, false, false, essentialTasks); % PASS: [ER] Aerobic rephosphorylation of ATP from glucose % PASS: [ER] Aerobic rephosphorylation of GTP % PASS: [ER] Aerobic rephosphorylation of CTP % PASS: [ER] Aerobic rephosphorylation of UTP % PASS: [BS] ATP de novo synthesis % PASS: [BS] CTP de novo synthesis % PASS: [BS] GTP de novo synthesis % PASS: [BS] UTP de novo synthesis % PASS: [BS] dATP de novo synthesis % ... Run tINIT Now all inputs are ready to run tINIT and extract a GEM specific to the liver tissue based on its corresponding RNA expression profile. Although it's not necessary to re-assign the input variables before calling the getINITModel2 function, we do it here to make the inputs very clear. Use the help getINITModel2 command to see more details on the function inputs and outputs. refModel = ihuman; % the reference model from which the GEM will be extracted tissue = 'liver'; % must match the tissue name in data_struct.tissues celltype = []; % used if tissues are subdivided into cell type, which is not the case here hpaData = []; % data structure containing protein abundance information (not used here) arrayData = data_struct; % data structure with gene (RNA) abundance information metabolomicsData = []; % list of metabolite names if metabolomic data is available removeGenes = true; % (default) remove lowly/non-expressed genes from the extracted GEM taskFile = []; % we already loaded the task file, so this input is not required useScoresForTasks = true; % (default) use expression data to decide which reactions to keep printReport = true; % (default) print status/completion report to screen taskStructure = essentialTasks; % metabolic task structure (used instead \"taskFile\") params = []; % additional optimization parameters for the INIT algorithm paramsFT = []; % additional optimization parameters for the fit-tasks algorithm Run the getINITModel2 function to extract the GEM liverGEM = getINITModel2(refModel, tissue, celltype, hpaData, arrayData, metabolomicsData, removeGenes, taskFile, useScoresForTasks, printReport, taskStructure, params, paramsFT); % ***Generating model for: liver % -Using array data % -Using metabolic tasks % % Reference model statistics: % 13070 reactions, 3067 genes % Mean reaction score: 4.0838 % Mean gene score: 5.5685 % Reactions with positive scores: 54.0857% % % Pruned model statistics: % 11884 reactions, 2494 genes % Mean reaction score: 4.1082 % Mean gene score: 5.351 % Reactions with positive scores: 54.1905% % % Reactions essential for tasks: % 386 reactions, 401 genes % Mean reaction score: 8.1834 % Mean gene score: 7.2771 % Reactions with positive scores: 86.7876% % % MILP detected. % Set parameter Username % Set parameter TimeLimit to value 1000 % Set parameter IntFeasTol to value 1e-09 % Set parameter MIPGap to value 1e-12 ... Warning This algorithm will take a while to run (30 min to 1 hr). It is therefore recommended that this is run on a compute cluster, especially when repeating for many different GEMs. Alternatively, we recommend using the new \"fast\" tINIT ( ftINIT ) algorithm, available from the RAVEN Toolbox. View instructions on using ftINIT here . Note In this example, we called getINITModel2 with one output, liverGEM . Use help getINITModel2 to see a description of the additional optional outputs. Once the optimization is complete, we can take a look at the extracted GEM. liverGEM % liverGEM = % % struct with fields: % % id: 'INITModel' % description: 'Automatically generated model for liver' % rxns: {7970\u00d71 cell} % mets: {6740\u00d71 cell} % S: [6740\u00d77970 double] % lb: [7970\u00d71 double] % ub: [7970\u00d71 double] % rev: [7970\u00d71 double] % c: [7970\u00d71 double] % b: [6740\u00d72 double] % comps: {10\u00d71 cell} % compNames: {10\u00d71 cell} % rxnNames: {7970\u00d71 cell} % grRules: {7970\u00d71 cell} % rxnGeneMat: [7970\u00d71904 double] % subSystems: {7970\u00d71 cell} % eccodes: {7970\u00d71 cell} % rxnNotes: {7970\u00d71 cell} % genes: {1904\u00d71 cell} % metNames: {6740\u00d71 cell} % metComps: [6740\u00d71 double] % inchis: {6740\u00d71 cell} % metFormulas: {6740\u00d71 cell} % rxnReferences: {7970\u00d71 cell} % rxnFrom: {7970\u00d71 cell} % metFrom: {6740\u00d71 cell} % rxnConfidenceScores: [7970\u00d71 double] % metCharges: [6740\u00d71 int64] % version: '1.12.0' % annotation: [1\u00d71 struct] % unconstrained: [6740\u00d71 double] % name: '' % geneFrom: {1904\u00d71 cell} It is recommended to change the model id to a more descriptive name than the default of \"INITModel\". This is particularly useful when analyzing several models together. liverGEM.id = 'liver'; Notice that the model has fewer reactions, metabolites, and genes compared to the reference model. numel(ihuman.rxns) - numel(liverGEM.rxns) % ans = % % 5100 numel(ihuman.mets) - numel(liverGEM.mets) % ans = % % 3294 numel(ihuman.genes) - numel(liverGEM.genes) % ans = % % 1163 It is also good to verify that the extracted GEM can also perform the required metabolic tasks. checkTasks(liverGEM, [], true, false, false, essentialTasks);","title":"GEM Extraction with tINIT (the older algorithm for extracting context-specific models)"},{"location":"gem_extraction_old_tINIT/#gem-extraction-with-tinit-the-older-algorithm-for-extracting-context-specific-models","text":"The original (2014) tINIT algorithm is implemented in the RAVEN Toolbox, where its main calling function is getINITModel . This guide is for the updated (2020) version of tINIT that is maintained on the Human-GEM repository, called the getINITModel2 function.","title":"GEM Extraction with tINIT (the older algorithm for extracting context-specific models)"},{"location":"gem_extraction_old_tINIT/#retrieve-the-data","text":"To demonstrate the use of tINIT, we will walk through an example that replicates part of the Human-GEM publication . The data used in this example can be retrieved from the Zenodo repository associated with the publication. Download the Zenodo repository .zip file, and extract.","title":"Retrieve the data"},{"location":"gem_extraction_old_tINIT/#prepare-the-transcriptomic-data","text":"Data from the condition, tissue, or cell type for which the GEM will be generated is necessary to determine which reactions from the reference model (Human-GEM) should be included. In this case, we are using RNA-Seq data (TPM normalized) that was originally obtained from the GTEx database . In MATLAB, load the gtex_median_tissue_tpm.txt file from the Zenodo repository tINIT_GEMs/data/ subdirectory. % replace 'my/path/' with the path on your system, or change to the directory with the file gtex_data = readtable('my/path/tINIT_GEMs/data/gtex_median_tissue_tpm.txt'); % take a look at the first few rows and columns of the table gtex_data(1:5,1:5) % ans = % % 5\u00d75 table % % genes adipose_tissue adrenal_gland blood_vessel bladder % ___________________ ______________ _____________ ____________ _______ % % {'ENSG00000223972'} 0.05458 0.0746 0.04535 0.05878 % {'ENSG00000227232'} 11.2 8.023 11.99 14.24 % {'ENSG00000243485'} 0.06012 0.08179 0.05278 0.06097 % {'ENSG00000237613'} 0.03653 0.0405 0.03668 0.04113 % {'ENSG00000268020'} 0.02565 0.03479 0 0 Extract information from the table into a structure called data_struct % extract the tissue and gene names data_struct.tissues = gtex_data.Properties.VariableNames(2:end)'; % sample (tissue) names data_struct.genes = gtex_data.genes; % gene names data_struct.levels = table2array(gtex_data(:, 2:end)); % gene TPM values Important The name of the data structure ( data_struct in this example) is not important. However, its fields ( genes , tissues , levels ) should not be changed. Note We don't actually need all of the data for this example since we are only generating a model for one tissue (liver). One could instead extract only the liver column into the levels field, and included only liver in the tissues field. Although the original tINIT implementation always compared gene expression in the tissue of interest to the average of all other provided tissues, the updated version enables the option to instead compare the expression to a threshold value. Here, we will use this alternative approach with a threshold value of 1 TPM. data_struct.threshold = 1; Note Exclude the threshold field from the data structure to use the original tINIT approach of comparing the gene expression in your tissue of interest with all other tissues. If you choose this approach, however, you must include the gene expression data from the other tissues so that the algorithm has something to compare to. Take a look at data_struct to make sure all the fields are present and have the expected dimensions data_struct % data_struct = % % struct with fields: % % tissues: {30\u00d71 cell} % genes: {56202\u00d71 cell} % levels: [56202\u00d730 double] % threshold: 1","title":"Prepare the transcriptomic data"},{"location":"gem_extraction_old_tINIT/#load-and-prepare-the-reference-gem","text":"The reference GEM from which the liver-specific model will be extracted is Human-GEM. Load the model from the Human-GEM.mat file in the Human-GEM repository load('Human-GEM.mat'); % loads model as a structure named \"ihuman\" Important The metabolic task evaluation and tINIT algorithms requires that the model is provided in \"closed form\"; i.e., it contains boundary metabolites . Therefore, the boundary metabolites must be added to the GEM before proceeding. Add boundary metabolites to the model ihuman = addBoundaryMets(ihuman); % Boundary metabolites were added to 1665 reactions. % New (boundary) versions of 1665 metabolites were added to the model. Note The exchange reactions should all be unbounded (e.g., lower and upper bounds of -1000 and 1000, respectively). Human-GEM is already provided in this format, so no additional changes are needed.","title":"Load and prepare the reference GEM"},{"location":"gem_extraction_old_tINIT/#prepare-the-metabolic-task-list","text":"The tINIT algorithm has the option to specify one or more metabolic tasks that the extracted model should be able to perform, such as transport of essential amino acids or production of biomass. Although task specification is not required, it is generally recommended to obtain a more functional extracted GEM, especially if it is going to be used in simulation-based analysis (e.g., FBA). Following with the procedure used in the Human-GEM manuscript, this example will use the list of 57 \"essential\" metabolic tasks that all cells are expected to be able to perform to be viable. Load the metabolicTasks_Essential.txt list of metabolic tasks from the data/metabolicTasks/ subdirectory of the Human-GEM repository using the RAVEN parseTaskList function. essentialTasks = parseTaskList('/my/path/Human-GEM/data/metabolicTasks/metabolicTasks_Essential.txt') % essentialTasks = % % 57\u00d71 struct array with fields: % % id % description % shouldFail % printFluxes % comments % inputs % LBin % UBin % outputs % LBout % UBout % equations % LBequ % UBequ % changed % LBrxn % UBrxn It is important to first verify that the reference model (Human-GEM) can successfully perform all of the tasks. If the reference model cannot perform a task, then neither can any GEM extracted from that model. Verify that the reference model passes all of the essential metabolic tasks. % see what the other inputs mean by typing \"help checkTasks\" checkTasks(ihuman, [], true, false, false, essentialTasks); % PASS: [ER] Aerobic rephosphorylation of ATP from glucose % PASS: [ER] Aerobic rephosphorylation of GTP % PASS: [ER] Aerobic rephosphorylation of CTP % PASS: [ER] Aerobic rephosphorylation of UTP % PASS: [BS] ATP de novo synthesis % PASS: [BS] CTP de novo synthesis % PASS: [BS] GTP de novo synthesis % PASS: [BS] UTP de novo synthesis % PASS: [BS] dATP de novo synthesis % ...","title":"Prepare the metabolic task list"},{"location":"gem_extraction_old_tINIT/#run-tinit","text":"Now all inputs are ready to run tINIT and extract a GEM specific to the liver tissue based on its corresponding RNA expression profile. Although it's not necessary to re-assign the input variables before calling the getINITModel2 function, we do it here to make the inputs very clear. Use the help getINITModel2 command to see more details on the function inputs and outputs. refModel = ihuman; % the reference model from which the GEM will be extracted tissue = 'liver'; % must match the tissue name in data_struct.tissues celltype = []; % used if tissues are subdivided into cell type, which is not the case here hpaData = []; % data structure containing protein abundance information (not used here) arrayData = data_struct; % data structure with gene (RNA) abundance information metabolomicsData = []; % list of metabolite names if metabolomic data is available removeGenes = true; % (default) remove lowly/non-expressed genes from the extracted GEM taskFile = []; % we already loaded the task file, so this input is not required useScoresForTasks = true; % (default) use expression data to decide which reactions to keep printReport = true; % (default) print status/completion report to screen taskStructure = essentialTasks; % metabolic task structure (used instead \"taskFile\") params = []; % additional optimization parameters for the INIT algorithm paramsFT = []; % additional optimization parameters for the fit-tasks algorithm Run the getINITModel2 function to extract the GEM liverGEM = getINITModel2(refModel, tissue, celltype, hpaData, arrayData, metabolomicsData, removeGenes, taskFile, useScoresForTasks, printReport, taskStructure, params, paramsFT); % ***Generating model for: liver % -Using array data % -Using metabolic tasks % % Reference model statistics: % 13070 reactions, 3067 genes % Mean reaction score: 4.0838 % Mean gene score: 5.5685 % Reactions with positive scores: 54.0857% % % Pruned model statistics: % 11884 reactions, 2494 genes % Mean reaction score: 4.1082 % Mean gene score: 5.351 % Reactions with positive scores: 54.1905% % % Reactions essential for tasks: % 386 reactions, 401 genes % Mean reaction score: 8.1834 % Mean gene score: 7.2771 % Reactions with positive scores: 86.7876% % % MILP detected. % Set parameter Username % Set parameter TimeLimit to value 1000 % Set parameter IntFeasTol to value 1e-09 % Set parameter MIPGap to value 1e-12 ... Warning This algorithm will take a while to run (30 min to 1 hr). It is therefore recommended that this is run on a compute cluster, especially when repeating for many different GEMs. Alternatively, we recommend using the new \"fast\" tINIT ( ftINIT ) algorithm, available from the RAVEN Toolbox. View instructions on using ftINIT here . Note In this example, we called getINITModel2 with one output, liverGEM . Use help getINITModel2 to see a description of the additional optional outputs. Once the optimization is complete, we can take a look at the extracted GEM. liverGEM % liverGEM = % % struct with fields: % % id: 'INITModel' % description: 'Automatically generated model for liver' % rxns: {7970\u00d71 cell} % mets: {6740\u00d71 cell} % S: [6740\u00d77970 double] % lb: [7970\u00d71 double] % ub: [7970\u00d71 double] % rev: [7970\u00d71 double] % c: [7970\u00d71 double] % b: [6740\u00d72 double] % comps: {10\u00d71 cell} % compNames: {10\u00d71 cell} % rxnNames: {7970\u00d71 cell} % grRules: {7970\u00d71 cell} % rxnGeneMat: [7970\u00d71904 double] % subSystems: {7970\u00d71 cell} % eccodes: {7970\u00d71 cell} % rxnNotes: {7970\u00d71 cell} % genes: {1904\u00d71 cell} % metNames: {6740\u00d71 cell} % metComps: [6740\u00d71 double] % inchis: {6740\u00d71 cell} % metFormulas: {6740\u00d71 cell} % rxnReferences: {7970\u00d71 cell} % rxnFrom: {7970\u00d71 cell} % metFrom: {6740\u00d71 cell} % rxnConfidenceScores: [7970\u00d71 double] % metCharges: [6740\u00d71 int64] % version: '1.12.0' % annotation: [1\u00d71 struct] % unconstrained: [6740\u00d71 double] % name: '' % geneFrom: {1904\u00d71 cell} It is recommended to change the model id to a more descriptive name than the default of \"INITModel\". This is particularly useful when analyzing several models together. liverGEM.id = 'liver'; Notice that the model has fewer reactions, metabolites, and genes compared to the reference model. numel(ihuman.rxns) - numel(liverGEM.rxns) % ans = % % 5100 numel(ihuman.mets) - numel(liverGEM.mets) % ans = % % 3294 numel(ihuman.genes) - numel(liverGEM.genes) % ans = % % 1163 It is also good to verify that the extracted GEM can also perform the required metabolic tasks. checkTasks(liverGEM, [], true, false, false, essentialTasks);","title":"Run tINIT"},{"location":"gem_extraction_sc/","text":"GEM Extraction from single-cell RNA-Seq data Single-cell RNA-Seq data is sparse, which means that samples (cells) contain much fewer mRNA molecules than what is normally the case for bulk RNA-Seq samples. It is therefore not recommended to generate context-specific models per individual cell - it is necessary to pool the transcriptomes of many cells gathered into a cell population to obtain a reliable gene expression profile. The typical use case is to generate context-specific models for cell types, where the transcriptomes of all cells classified as belonging to each type are pooled into a single cell type profile. Generation of context-specific models from single-cell RNA-Seq data is further described in Gustafsson et al. (2022) BioRXiv . Download the data Single-cell RNA-Seq data come in many forms and there are many different technologies available to obtain such data. We will not go through these methods here, but assume that each cell population to examine is available in matrix form, where rows are genes and columns are cells. We recommend to use either R or python to assemble the single-cell data into such matrices, where for example the R package Seurat is suitable. We have extracted an NK cell population (10X Chromium data) from Kim et al. (2020) Nature Communications , which is available as part of the downloadable files in Zenodo associated with this guide. Estimation of the minimum cell population size for generation of stable models The number of cells that needs to be pooled to generate stable models varies across cell types and datasets. To estimate the minimum number of cells required to generate a stable model we use the tool DSAVE described in Gustafsson et al. (2020) PLOS ONE . This can be installed using the following commands in R: # Install and load devtools: install.packages(\"devtools\") library(devtools) install_github(\"SysBioChalmers/DSAVE-R\") We then estimate the required number of cells: library(tidyverse) library(ggplot2) library(DSAVE) setwd(\"my/path\") #replace with your own path where the exported data was saved scData = readRDS(\"NKPopForTutorial.rds\") #Run DSAVE and plot it varNK = DSAVEGetTotalVariationPoolSize(scData, upperBound = 50, lowerBound = 5e-1) fig = DSAVEPlotTotalVariation(varNK, c(\"NK Cells\"), bulkIndex = 4) fig #export the figure to file ggsave( \"DSAVE.png\", plot = fig, width = 5, height = 5, dpi = 300) We conclude that we need at least somewhere between 1,500 to 2,000 cells to get a similar variation as between bulk samples (the blue line) for this population. Note The DSAVE method can only test pool sizes up to half of the total population size. To investigate several populations in a dataset, it is therefore recommended to look at the large cell populations, check that the smaller ones have similar number of UMIs/counts per cell, and then use the larger cell population to estimate the minimum required number of cells for all populations. Pool the data To pool the data into a profile, we simply add up the counts/UMIs from all cells in the population. We also convert the gene expression profile to counts per million (CPM) as a preparation for use with ftINIT. library(textTinyR) # needed for rowSums to work with sparse matrices genes = rownames(scData) gexProfile = rowSums(scData) toExport = tibble(genes = genes, NKCells = gexProfile) # convert the data to CPM (counts per million, comparable to TPM) toExport[[2]] = toExport[[2]]*10^6 / sum(toExport[[2]]) # always check that it worked sum(toExport[[2]]) # 10^6 write_tsv(toExport, 'NKCells.txt') The text file can then be imported to MATLAB followed by generation of a context-specific model by ftINIT in a similar way that was shown for the GTEx data . In this case, prepHumanModelForftINIT must be run with gene symbol conversion turned on ( prepHumanModelForftINIT(model, true) ), since the genes in this table are in the gene symbols format. Estimation of the uncertainty in generated models To estimate the uncertainty in models generated from single-cell RNA-Seq data, it is possible to generate bootstraps (samples of cells) from the single-cell data. Bootstrapping is a method for generating samples with appropriate variation from the full population, and can be used to estimate the uncertainty in the model generation. How bootstraps can be used is demonstrated in Gustafsson et al. (2022) BioRXiv . library(textTinyR) # needed for rowSums to work with sparse matrices set.seed(1) # make reproducible pooledBootstraps = Matrix(0, nrow = length(genes), ncol=100) rownames(pooledBootstraps) = genes for (j in 1:100) { # bootstrap,i.e. sample the same number of samples with replacement sel = sample(ncol(scData),ncol(scData), replace = TRUE) pooledBootstraps[, j] = rowSums(scData[, sel]) } tibbBstr = as_tibble(pooledBootstraps) %>% add_column(gene = genes, .before = 1) write_tsv(tibbBstr, \"NKCell_bootstraps.txt\") Models are generated the same way from bootstrap samples as from other data. The variation in analysis results can then be examined across the bootstrap models. Examples of how such analysis can be performed can be found in the code associated with Gustafsson et al. (2022) BioRXiv .","title":"GEM extraction from scRNA-Seq data"},{"location":"gem_extraction_sc/#gem-extraction-from-single-cell-rna-seq-data","text":"Single-cell RNA-Seq data is sparse, which means that samples (cells) contain much fewer mRNA molecules than what is normally the case for bulk RNA-Seq samples. It is therefore not recommended to generate context-specific models per individual cell - it is necessary to pool the transcriptomes of many cells gathered into a cell population to obtain a reliable gene expression profile. The typical use case is to generate context-specific models for cell types, where the transcriptomes of all cells classified as belonging to each type are pooled into a single cell type profile. Generation of context-specific models from single-cell RNA-Seq data is further described in Gustafsson et al. (2022) BioRXiv .","title":"GEM Extraction from single-cell RNA-Seq data"},{"location":"gem_extraction_sc/#download-the-data","text":"Single-cell RNA-Seq data come in many forms and there are many different technologies available to obtain such data. We will not go through these methods here, but assume that each cell population to examine is available in matrix form, where rows are genes and columns are cells. We recommend to use either R or python to assemble the single-cell data into such matrices, where for example the R package Seurat is suitable. We have extracted an NK cell population (10X Chromium data) from Kim et al. (2020) Nature Communications , which is available as part of the downloadable files in Zenodo associated with this guide.","title":"Download the data"},{"location":"gem_extraction_sc/#estimation-of-the-minimum-cell-population-size-for-generation-of-stable-models","text":"The number of cells that needs to be pooled to generate stable models varies across cell types and datasets. To estimate the minimum number of cells required to generate a stable model we use the tool DSAVE described in Gustafsson et al. (2020) PLOS ONE . This can be installed using the following commands in R: # Install and load devtools: install.packages(\"devtools\") library(devtools) install_github(\"SysBioChalmers/DSAVE-R\") We then estimate the required number of cells: library(tidyverse) library(ggplot2) library(DSAVE) setwd(\"my/path\") #replace with your own path where the exported data was saved scData = readRDS(\"NKPopForTutorial.rds\") #Run DSAVE and plot it varNK = DSAVEGetTotalVariationPoolSize(scData, upperBound = 50, lowerBound = 5e-1) fig = DSAVEPlotTotalVariation(varNK, c(\"NK Cells\"), bulkIndex = 4) fig #export the figure to file ggsave( \"DSAVE.png\", plot = fig, width = 5, height = 5, dpi = 300) We conclude that we need at least somewhere between 1,500 to 2,000 cells to get a similar variation as between bulk samples (the blue line) for this population. Note The DSAVE method can only test pool sizes up to half of the total population size. To investigate several populations in a dataset, it is therefore recommended to look at the large cell populations, check that the smaller ones have similar number of UMIs/counts per cell, and then use the larger cell population to estimate the minimum required number of cells for all populations.","title":"Estimation of the minimum cell population size for generation of stable models"},{"location":"gem_extraction_sc/#pool-the-data","text":"To pool the data into a profile, we simply add up the counts/UMIs from all cells in the population. We also convert the gene expression profile to counts per million (CPM) as a preparation for use with ftINIT. library(textTinyR) # needed for rowSums to work with sparse matrices genes = rownames(scData) gexProfile = rowSums(scData) toExport = tibble(genes = genes, NKCells = gexProfile) # convert the data to CPM (counts per million, comparable to TPM) toExport[[2]] = toExport[[2]]*10^6 / sum(toExport[[2]]) # always check that it worked sum(toExport[[2]]) # 10^6 write_tsv(toExport, 'NKCells.txt') The text file can then be imported to MATLAB followed by generation of a context-specific model by ftINIT in a similar way that was shown for the GTEx data . In this case, prepHumanModelForftINIT must be run with gene symbol conversion turned on ( prepHumanModelForftINIT(model, true) ), since the genes in this table are in the gene symbols format.","title":"Pool the data"},{"location":"gem_extraction_sc/#estimation-of-the-uncertainty-in-generated-models","text":"To estimate the uncertainty in models generated from single-cell RNA-Seq data, it is possible to generate bootstraps (samples of cells) from the single-cell data. Bootstrapping is a method for generating samples with appropriate variation from the full population, and can be used to estimate the uncertainty in the model generation. How bootstraps can be used is demonstrated in Gustafsson et al. (2022) BioRXiv . library(textTinyR) # needed for rowSums to work with sparse matrices set.seed(1) # make reproducible pooledBootstraps = Matrix(0, nrow = length(genes), ncol=100) rownames(pooledBootstraps) = genes for (j in 1:100) { # bootstrap,i.e. sample the same number of samples with replacement sel = sample(ncol(scData),ncol(scData), replace = TRUE) pooledBootstraps[, j] = rowSums(scData[, sel]) } tibbBstr = as_tibble(pooledBootstraps) %>% add_column(gene = genes, .before = 1) write_tsv(tibbBstr, \"NKCell_bootstraps.txt\") Models are generated the same way from bootstrap samples as from other data. The variation in analysis results can then be examined across the bootstrap models. Examples of how such analysis can be performed can be found in the code associated with Gustafsson et al. (2022) BioRXiv .","title":"Estimation of the uncertainty in generated models"},{"location":"getting_started/","text":"Getting Started Make sure you have completed the installation process before continuing. The commands described on this page are all run from the MATLAB command prompt, unless otherwise noted. Loading Human-GEM into MATLAB Important The Human-GEM model files are provided in a RAVEN-friendly format . If you intend on using COBRA , see the Using Human-GEM with COBRA section below. Note All the model file formats described below are on the main branch of the Human-GEM repository. Note that only the .yml version is available on branches other than main (e.g., devel ), to facilitate tracking of model changes. From the Human-GEM.mat file (recommended) The quickest and easiest way to load the Human-GEM model is from the .mat file. load('Human-GEM.mat'); This will load the model as a structure named ihuman . ihuman % ihuman = % % struct with fields: % % id: 'Human-GEM' % description: 'Generic genome-scale metabolic model of Homo sapiens' % rxns: {13070\u00d71 cell} % mets: {8369\u00d71 cell} % S: [8369\u00d713070 double] % lb: [13070\u00d71 double] % ub: [13070\u00d71 double] % rev: [13070\u00d71 double] % c: [13070\u00d71 double] % b: [8369\u00d71 double] % comps: {9\u00d71 cell} % compNames: {9\u00d71 cell} % rxnNames: {13070\u00d71 cell} % grRules: {13070\u00d71 cell} % rxnGeneMat: [13070\u00d73067 double] % subSystems: {13070\u00d71 cell} % eccodes: {13070\u00d71 cell} % rxnNotes: {13070\u00d71 cell} % genes: {3067\u00d71 cell} % metNames: {8369\u00d71 cell} % metComps: [8369\u00d71 double] % inchis: {8369\u00d71 cell} % metFormulas: {8369\u00d71 cell} % rxnReferences: {13070\u00d71 cell} % rxnFrom: {13070\u00d71 cell} % metFrom: {8369\u00d71 cell} % rxnConfidenceScores: [13070\u00d71 double] % metCharges: [8369\u00d71 int64] % version: '1.12.0' % annotation: [1\u00d71 struct] From the Human-GEM.yml file (recommended if not on main branch or if using Cobrapy) The yaml version of Human-GEM is loaded using the importYaml function. ihuman = importYaml('Human-GEM.yml'); % 1 % 2 % 3 % 4 % 5 % % importing completed % follow-up processing... Done! From the Human-GEM.xml (SBML) file The .xml (SBML) version of Human-GEM is loaded using the RAVEN importHumanYaml function. ihuman = importModel(which('Human-GEM.xml')); % The model contains 0 errors and 1 warnings. % % WARNING: Potentially problematic \") AND (\" in the grRules for reaction(s): % MAR04137 % MAR07161 % MAR07162 % MAR00080 Note The warning regarding the grRules can be ignored. Some packages are a bit more strict in their gene-reaction rule formulation, but Human-GEM functions do not have such restrictions. Note We include the which() command around the model filename to provide its full path because some functions cannot otherwise find the file. This is not necessary if the model file is in MATLAB's current working directory (i.e., if you can see the model file in the Current Folder window), or if you provide the full path to the file. From the Human-GEM.xlsx file The .xslx (Excel) version of Human-GEM is loaded using the RAVEN importExcelModel function. ihuman = importExcelModel(which('Human-GEM.xlsx')); % WARNING: Potentially problematic \") AND (\" in the grRules for reaction(s): % MAR04137 % MAR07161 % MAR07162 % MAR00080 From the Human-GEM.txt file There is no function to import the .txt version of the model. The Human-GEM.txt file is supplied for those who need or prefer a more human-readable plain-text format, but is not intended for loading into MATLAB. Using Human-GEM with COBRA The provided Human-GEM models can generally be used directly with COBRA, though there may remain some incompatibilities that cause errors or unexpected behavior. We suggest to first convert the model to a COBRA-friendly format before using the COBRA Toolbox. 1. Load the model into MATLAB Use one of the methods described above to load Human-GEM into MATLAB. load('Human-GEM.mat'); % loads model as structure named \"ihuman\" 2. Convert the model into COBRA format Use the RAVEN ravenCobraWrapper function to convert the model into a COBRA-friendly format. model = ravenCobraWrapper(ihuman); % Converting RAVEN structure to COBRA.. The resulting model output should now be ready for use with the COBRA Toolbox. Alternative approach (not recommended) Another option is to load the SBML model Human-GEM.xml directly into COBRA format using the COBRA readCbModel function. model = readCbModel(which('Human-GEM.xml')); % The model contains 0 errors and 1 warnings. Warning Since the SBML file is not formatted for COBRA, loading it using readCbModel will yield a model that may be missing content or exhibit unexpected behavior. Proceed with caution.","title":"Getting started"},{"location":"getting_started/#getting-started","text":"Make sure you have completed the installation process before continuing. The commands described on this page are all run from the MATLAB command prompt, unless otherwise noted.","title":"Getting Started"},{"location":"getting_started/#loading-human-gem-into-matlab","text":"Important The Human-GEM model files are provided in a RAVEN-friendly format . If you intend on using COBRA , see the Using Human-GEM with COBRA section below. Note All the model file formats described below are on the main branch of the Human-GEM repository. Note that only the .yml version is available on branches other than main (e.g., devel ), to facilitate tracking of model changes.","title":"Loading Human-GEM into MATLAB"},{"location":"getting_started/#from-the-human-gemmat-file-recommended","text":"The quickest and easiest way to load the Human-GEM model is from the .mat file. load('Human-GEM.mat'); This will load the model as a structure named ihuman . ihuman % ihuman = % % struct with fields: % % id: 'Human-GEM' % description: 'Generic genome-scale metabolic model of Homo sapiens' % rxns: {13070\u00d71 cell} % mets: {8369\u00d71 cell} % S: [8369\u00d713070 double] % lb: [13070\u00d71 double] % ub: [13070\u00d71 double] % rev: [13070\u00d71 double] % c: [13070\u00d71 double] % b: [8369\u00d71 double] % comps: {9\u00d71 cell} % compNames: {9\u00d71 cell} % rxnNames: {13070\u00d71 cell} % grRules: {13070\u00d71 cell} % rxnGeneMat: [13070\u00d73067 double] % subSystems: {13070\u00d71 cell} % eccodes: {13070\u00d71 cell} % rxnNotes: {13070\u00d71 cell} % genes: {3067\u00d71 cell} % metNames: {8369\u00d71 cell} % metComps: [8369\u00d71 double] % inchis: {8369\u00d71 cell} % metFormulas: {8369\u00d71 cell} % rxnReferences: {13070\u00d71 cell} % rxnFrom: {13070\u00d71 cell} % metFrom: {8369\u00d71 cell} % rxnConfidenceScores: [13070\u00d71 double] % metCharges: [8369\u00d71 int64] % version: '1.12.0' % annotation: [1\u00d71 struct]","title":"From the Human-GEM.mat file (recommended)"},{"location":"getting_started/#from-the-human-gemyml-file-recommended-if-not-on-main-branch-or-if-using-cobrapy","text":"The yaml version of Human-GEM is loaded using the importYaml function. ihuman = importYaml('Human-GEM.yml'); % 1 % 2 % 3 % 4 % 5 % % importing completed % follow-up processing... Done!","title":"From the Human-GEM.yml file (recommended if not on main branch or if using Cobrapy)"},{"location":"getting_started/#from-the-human-gemxml-sbml-file","text":"The .xml (SBML) version of Human-GEM is loaded using the RAVEN importHumanYaml function. ihuman = importModel(which('Human-GEM.xml')); % The model contains 0 errors and 1 warnings. % % WARNING: Potentially problematic \") AND (\" in the grRules for reaction(s): % MAR04137 % MAR07161 % MAR07162 % MAR00080 Note The warning regarding the grRules can be ignored. Some packages are a bit more strict in their gene-reaction rule formulation, but Human-GEM functions do not have such restrictions. Note We include the which() command around the model filename to provide its full path because some functions cannot otherwise find the file. This is not necessary if the model file is in MATLAB's current working directory (i.e., if you can see the model file in the Current Folder window), or if you provide the full path to the file.","title":"From the Human-GEM.xml (SBML) file"},{"location":"getting_started/#from-the-human-gemxlsx-file","text":"The .xslx (Excel) version of Human-GEM is loaded using the RAVEN importExcelModel function. ihuman = importExcelModel(which('Human-GEM.xlsx')); % WARNING: Potentially problematic \") AND (\" in the grRules for reaction(s): % MAR04137 % MAR07161 % MAR07162 % MAR00080","title":"From the Human-GEM.xlsx file"},{"location":"getting_started/#from-the-human-gemtxt-file","text":"There is no function to import the .txt version of the model. The Human-GEM.txt file is supplied for those who need or prefer a more human-readable plain-text format, but is not intended for loading into MATLAB.","title":"From the Human-GEM.txt file"},{"location":"getting_started/#using-human-gem-with-cobra","text":"The provided Human-GEM models can generally be used directly with COBRA, though there may remain some incompatibilities that cause errors or unexpected behavior. We suggest to first convert the model to a COBRA-friendly format before using the COBRA Toolbox.","title":"Using Human-GEM with COBRA"},{"location":"getting_started/#1-load-the-model-into-matlab","text":"Use one of the methods described above to load Human-GEM into MATLAB. load('Human-GEM.mat'); % loads model as structure named \"ihuman\"","title":"1. Load the model into MATLAB"},{"location":"getting_started/#2-convert-the-model-into-cobra-format","text":"Use the RAVEN ravenCobraWrapper function to convert the model into a COBRA-friendly format. model = ravenCobraWrapper(ihuman); % Converting RAVEN structure to COBRA.. The resulting model output should now be ready for use with the COBRA Toolbox.","title":"2. Convert the model into COBRA format"},{"location":"getting_started/#alternative-approach-not-recommended","text":"Another option is to load the SBML model Human-GEM.xml directly into COBRA format using the COBRA readCbModel function. model = readCbModel(which('Human-GEM.xml')); % The model contains 0 errors and 1 warnings. Warning Since the SBML file is not formatted for COBRA, loading it using readCbModel will yield a model that may be missing content or exhibit unexpected behavior. Proceed with caution.","title":"Alternative approach (not recommended)"},{"location":"installation/","text":"Installation Human-GEM The Human-GEM model is maintained in a GitHub repository to track changes and facilitate collaboration. In addition to several different model formats (e.g., .mat , .xml , .yml ), the repository contains a number of functions and data files that support Human-GEM analysis, maintenance, editing, and other actions. We therefore recommend cloning the GitHub repository to gain full functionality and easy access to the most updated version of Human-GEM. Note Although the functions contained within the Human-GEM repository require MATLAB , the model itself can still be used with other languages such as Python (see section below on COBRApy ). 1. Clone the repository (recommended) Clone the repository using git . Navigate to the directory where you would like to save the Human-GEM repository, and in the command line/terminal run: git clone https://github.com/SysBioChalmers/Human-GEM.git This will create a copy of the repository contents on your local machine. 1b. Alternative: Download as a .zip The latest release of the repository can be downloaded as a .zip or .tar.gz file . Download the file using the link, and unzip/expand the file. 2. Add the repository to the MATLAB path In order for MATLAB to find and use the functions and files in the repository directory (and subdirectories), they need to be added to the PATH. In MATLAB, select HOME from the top menu bar, and choose Set Path and then Add with Subfolders... . Choose the code/ , data/ , and model/ subdirectories in the Human-GEM folder to be added to the path, and click Save when finished. Alternatively, you can run the following lines in MATLAB: cd /my/path/Human-GEM % replace \"/my/path/\" with the actual path to the Human-GEM folder addpath(strjoin(cellfun(@genpath, split(ls), 'UniformOutput', false), '')); savepath Ignore the Warning: Name is nonexistent or not a directory messages. Required software MATLAB [R2018 or newer] MATLAB is the primary software used for working with Human-GEM. Unfortunately, MATLAB is not free, though a ( 30-day trial ) is available. The RAVEN Toolbox [v2.7.5 or newer] The Human-GEM model files are provided in RAVEN-friendly format, and many of the functions in the Human-GEM repository depend on the RAVEN Toolbox. Ensure that the RAVEN Toolbox is installed and added to your MATLAB path. See the RAVEN installation instructions for more detail. The COBRA Toolbox (optional) The COBRA Toolbox is not required for most of the functions associated with Human-GEM. However, it offers many additional analysis tools that are not available in RAVEN, and can for the most part be used instead of RAVEN. Important The Human-GEM model files were originally designed for use with the RAVEN Toolbox. Although the model should be compatible with most COBRA functions as-is, it may be necessary to first convert the model to a COBRA-friendly format in MATLAB using the ravenCobraWrapper function from the RAVEN Toolbox: cobraModel = ravenCobraWrapper(ravenModel); Note There is an ongoing effort to align the model structures of RAVEN and COBRA to eliminate compatibility issues, so hopefully this will soon be a problem of the past. Linear optimization solver A solver is required to run flux balance analysis (FBA), GEM extraction (using tINIT), or any other function involving an optimization. Compatible solvers are Gurobi Optimizer (recommended), GLPK, or the COBRA solver. Important We strongly recommend using the Gurobi Optimizer, as issues are sometimes observed for other solvers since Human-GEM is a relatively large model. For instructions on how to set up a solver and obtain a license (if required), see the RAVEN instructions . Alternative software COBRApy The functions contained within the Human-GEM GitHub repository are written in MATLAB, but the Human-GEM model can be used outside of MATLAB; for example, with Python (COBRApy). COBRApy is a Python package that allows users to perform constraint-based reconstruction and analysis of genome-scale metabolic models. See the COBRApy Documentation for instructions on how to install and use COBRApy. Note We recommend using the YAML ( Human-GEM.yml ) or SBML ( Human-GEM.xml ) versions of Human-GEM with COBRApy.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#human-gem","text":"The Human-GEM model is maintained in a GitHub repository to track changes and facilitate collaboration. In addition to several different model formats (e.g., .mat , .xml , .yml ), the repository contains a number of functions and data files that support Human-GEM analysis, maintenance, editing, and other actions. We therefore recommend cloning the GitHub repository to gain full functionality and easy access to the most updated version of Human-GEM. Note Although the functions contained within the Human-GEM repository require MATLAB , the model itself can still be used with other languages such as Python (see section below on COBRApy ).","title":"Human-GEM"},{"location":"installation/#1-clone-the-repository-recommended","text":"Clone the repository using git . Navigate to the directory where you would like to save the Human-GEM repository, and in the command line/terminal run: git clone https://github.com/SysBioChalmers/Human-GEM.git This will create a copy of the repository contents on your local machine.","title":"1. Clone the repository (recommended)"},{"location":"installation/#1b-alternative-download-as-a-zip","text":"The latest release of the repository can be downloaded as a .zip or .tar.gz file . Download the file using the link, and unzip/expand the file.","title":"1b. Alternative: Download as a .zip"},{"location":"installation/#2-add-the-repository-to-the-matlab-path","text":"In order for MATLAB to find and use the functions and files in the repository directory (and subdirectories), they need to be added to the PATH. In MATLAB, select HOME from the top menu bar, and choose Set Path and then Add with Subfolders... . Choose the code/ , data/ , and model/ subdirectories in the Human-GEM folder to be added to the path, and click Save when finished. Alternatively, you can run the following lines in MATLAB: cd /my/path/Human-GEM % replace \"/my/path/\" with the actual path to the Human-GEM folder addpath(strjoin(cellfun(@genpath, split(ls), 'UniformOutput', false), '')); savepath Ignore the Warning: Name is nonexistent or not a directory messages.","title":"2. Add the repository to the MATLAB path"},{"location":"installation/#required-software","text":"","title":"Required software"},{"location":"installation/#matlab","text":"[R2018 or newer] MATLAB is the primary software used for working with Human-GEM. Unfortunately, MATLAB is not free, though a ( 30-day trial ) is available.","title":"MATLAB"},{"location":"installation/#the-raven-toolbox","text":"[v2.7.5 or newer] The Human-GEM model files are provided in RAVEN-friendly format, and many of the functions in the Human-GEM repository depend on the RAVEN Toolbox. Ensure that the RAVEN Toolbox is installed and added to your MATLAB path. See the RAVEN installation instructions for more detail.","title":"The RAVEN Toolbox"},{"location":"installation/#the-cobra-toolbox-optional","text":"The COBRA Toolbox is not required for most of the functions associated with Human-GEM. However, it offers many additional analysis tools that are not available in RAVEN, and can for the most part be used instead of RAVEN. Important The Human-GEM model files were originally designed for use with the RAVEN Toolbox. Although the model should be compatible with most COBRA functions as-is, it may be necessary to first convert the model to a COBRA-friendly format in MATLAB using the ravenCobraWrapper function from the RAVEN Toolbox: cobraModel = ravenCobraWrapper(ravenModel); Note There is an ongoing effort to align the model structures of RAVEN and COBRA to eliminate compatibility issues, so hopefully this will soon be a problem of the past.","title":"The COBRA Toolbox (optional)"},{"location":"installation/#linear-optimization-solver","text":"A solver is required to run flux balance analysis (FBA), GEM extraction (using tINIT), or any other function involving an optimization. Compatible solvers are Gurobi Optimizer (recommended), GLPK, or the COBRA solver. Important We strongly recommend using the Gurobi Optimizer, as issues are sometimes observed for other solvers since Human-GEM is a relatively large model. For instructions on how to set up a solver and obtain a license (if required), see the RAVEN instructions .","title":"Linear optimization solver"},{"location":"installation/#alternative-software","text":"","title":"Alternative software"},{"location":"installation/#cobrapy","text":"The functions contained within the Human-GEM GitHub repository are written in MATLAB, but the Human-GEM model can be used outside of MATLAB; for example, with Python (COBRApy). COBRApy is a Python package that allows users to perform constraint-based reconstruction and analysis of genome-scale metabolic models. See the COBRApy Documentation for instructions on how to install and use COBRApy. Note We recommend using the YAML ( Human-GEM.yml ) or SBML ( Human-GEM.xml ) versions of Human-GEM with COBRApy.","title":"COBRApy"}]}